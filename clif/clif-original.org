#+title: clif: The common lisp interactive fiction system
#+AUTHOR: Fernando Raul Rodriguez Flores

#+TODO: HERE TODO | DONE

* Description
  In this file I'm going to write (in a literate programming style) the source code for clif: The common lisp interactive fiction system.

  Clif is a language designed for the creation of choose your own adventure stories.  The goal is to use them in the writing of the conferences of  mathematical courses.
  
  After the story is written in clif it will be possible to export it to several backends.  In the beginning, we are only going to use one backend: undum.

  We are going to use the library gagm.


* package definition

** description
   In this section we define the package for clif.
   
   So far (2024-10-23), we are just creating the package and using gagm.  We are not shadowing any symbols (for now).
** code
   #+begin_src lisp :results none :export code :tangle src/package.lisp
   (defpackage :clif
     (:use :cl :gagm))
   #+end_src




* utilities
** description
   In this section I'll add some basic utilities that will be used all over the system.

** declare the package in utilities.lisp
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/utilities.lisp
   (in-package :clif)
   #+END_SRC

** symb,flatten and make-keyword
   
The first two utilities are symb and flatten.  The first one allows us to create symbols (useful for macro definitions), and flatten receives a tree and returns a flattened version of it.  It is useful in some macros.

*** mkstr and symb

   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/utilities.lisp
   (defun mkstr (&rest args)
     "Returns a string with the concatenation of the args"
     (string-upcase
      (with-output-to-string (s)
        (dolist (a args) (princ a s)))))

   (defun symb (&rest args)
     "Returns a symbol formed by the concatenation of the args."
     (values (intern (apply #'mkstr args))))
   #+END_SRC

*** flatten
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/utilities.lisp
    (defun flatten (x)
      "Flattens a structure."
      (labels ((rec (x acc)
                 (cond ((null x) acc)
                       ((atom x) (cons x acc))
                       (t (rec (car x) (rec (cdr x) acc))))))
        (rec x nil)))
    #+END_SRC    

*** make-keyword
    The idea is to create a keyword like =:name=.

    To make a keyword you just need to insert the symbol into the =:keyword= package.

    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/utilities.lisp
    (defun make-keyword (&rest args)
      (values (intern (apply #'mkstr args) :keyword)))
    #+END_SRC
    
** format-boxed
*** description
    This is a function very similar to format, but it prints two lines of `=', one above the format string and the other below.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/utilities.lisp
   (defun format-boxed (stream format-str &rest format-args)
     (let* ((string-to-print
             (if format-args
                 (apply 'format `(nil ,format-str ,@format-args))
                 (funcall 'format nil format-str)))
            (length (cl:+ 2 (length string-to-print)))
            (=-line (make-string length :initial-element #\=)))
       (format stream "~a~% ~a~%~a~2%"
               =-line string-to-print =-line)))

   (setf (symbol-function 'bformat) #'format-boxed)
   #+END_SRC   

** emacs-utils
*** description
    In this section I'll add the utilities to work with emacs.
*** code
   #+BEGIN_SRC emacs-lisp :results none :exports code :tangle src/emacs-utils.el
   ;; key to insert (load everything.lisp) in the repl
   (define-key lisp-mode-map (kbd "M-m M-o M-l")
     (lambda ()
       (interactive)
       (insert "(load \"src/load-clif.lisp\") (in-package :clif)")))
   #+END_SRC


* macros
** documentation
In this section I'll add the macros that will be used in the code.  All src blocks will be tangled to src/macros.lisp
** add the package to the file
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/macros.lisp
   (in-package :clif)
   #+END_SRC
** macro make-html-tag-constructor
*** description
The idea with this macro, is that when we create the constructor for an html-tag we need to separate the keywords in the content, that will represent the css-classes.  

We do that with a couple of loops, but I want to abstract that, because I did it twice already (for h1 and p) :grim:, and I need a third one (for link), so It is more than two times, which is the rule of thumb, so...  let's write that macro :-).

The idea (so far) is to be able to write something like:

#+begin_src lisp
(make-html-tag-constructor h1 (&rest contents)
  (make-instance 'html-h1
                 :css-classes css-classes
                 :contents actual-contents))
#+end_src

I want to leave it there, and not optimize it more, because I don't know if some other tags will need more parameters...  

The idea is:

#+begin_src lisp
(make-html-tag-constructor ctr-name lambda-list
  @body  ;; where you'll have css-classes and actual-contents
  ;; maybe you want to further process some of those lists
  ;; or I don't know :shrugs:
 )
#+end_src

Here is the hand-coded expected result:

   #+begin_src lisp :results none :export code 
   (defun h1 (&rest contents)
     (let* (css-classes
            actual-contents)
       ;; let's separate teh css-classes from the contents
       (loop for elt in contents
             doing
             (if (keywordp elt)
                 ;; if it is a keyword, let's store it as a downcase string 
                 (push (string-downcase (symbol-name elt)) css-classes)
                 ;; else
                 (push elt actual-contents)))
       ;; let's create the class
       (make-instance 'html-h1
                      :css-classes (reverse css-classes)
                      :contents (reverse actual-contents))))
   #+end_src

That should be the final result.

Let's code it :-)

*** code for the macro
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/macros.lisp
   (defmacro make-html-tag-constructor (ctr-name (&rest lambda-list) &body body)
     "In the lambda list there should be an argument named contents, and it should be a list."
     `(defun ,ctr-name ,lambda-list
        (let* (css-classes
               actual-contents)
          ;; let's separate teh css-classes from the contents
          (loop for elt in contents
                doing
                (if (keywordp elt)
                    ;; if it is a keyword, let's store it as a downcase string 
                    (push (string-downcase (symbol-name elt)) css-classes)
                    ;; else
                    (push elt actual-contents)))
          ;; now let's reverse the css-classes and actual-contents
          (setf css-classes (reverse css-classes))
          (setf actual-contents (reverse actual-contents))
          ;; let's create the class
          ;; that should do it the final user
          ,@body)))
   #+END_SRC

*** test macro expansion
   #+begin_src lisp :results none :export code 
   (make-html-tag-constructor h1 (&rest contents)
     (make-instance 'html-h1
                    :css-classes css-classes
                    :contents actual-contents))
   #+end_src

   #+begin_src lisp
   (DEFUN H1 (&REST CONTENTS)
     (LET* (CSS-CLASSES ACTUAL-CONTENTS)
       (LOOP FOR ELT IN CONTENTS
             DOING (IF (KEYWORDP ELT)
                       (PUSH (STRING-DOWNCASE (SYMBOL-NAME ELT)) CSS-CLASSES)
                       (PUSH ELT ACTUAL-CONTENTS)))
       (SETF CSS-CLASSES (REVERSE CSS-CLASSES))
       (SETF ACTUAL-CONTENTS (REVERSE ACTUAL-CONTENTS))
       (MAKE-INSTANCE 'HTML-H1 :CSS-CLASSES CSS-CLASSES :CONTENTS
                      ACTUAL-CONTENTS)))
   #+end_src

** macro make-simple-html-tag-constructor
*** description
This macro is similar to the previous one, but the idea is that there are some html-tags for which there is nothing else to do than to create the instance.  For those very simple situations this macro does everything.

The idea is to be able to write:

#+begin_src lisp
(make-simple-html-tag-constructor h1 html-h1)
#+end_src

And that creates everything and we get the following:

   #+begin_src lisp :results none :export code 
   (defun h1 (&rest contents)
     (let* (css-classes
            actual-contents)
       ;; let's separate teh css-classes from the contents
       (loop for elt in contents
             doing
             (if (keywordp elt)
                 ;; if it is a keyword, let's store it as a downcase string 
                 (push (string-downcase (symbol-name elt)) css-classes)
                 ;; else
                 (push elt actual-contents)))
       (setf css-classes (reverse css-classes))
       (setf actual-contents (reverse actual-contents))
       ;; let's create the class
       (make-instance 'html-h1
                      :css-classes css-classes
                      :contents actual-contents)))
   #+end_src
   
This should work, at least with the html-tags that we have right now (h1 and p).

*** code for the macro
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/macros.lisp
   (defmacro make-simple-html-tag-constructor (ctr-name class-name)
     `(make-html-tag-constructor ,ctr-name (&rest contents)
        (make-instance ',class-name
                       :css-classes css-classes
                       :contents actual-contents)))
   #+END_SRC

*** test macro expansion
   #+begin_src lisp :results none :export code 
   (make-simple-html-tag-constructor h1 html-h1)
   #+end_src
   Expands into:
   
   #+begin_src lisp
   (DEFUN H1 (&REST CONTENTS)
     (LET* (CSS-CLASSES ACTUAL-CONTENTS)
       (LOOP FOR ELT IN CONTENTS
             DOING (IF (KEYWORDP ELT)
                       (PUSH (STRING-DOWNCASE (SYMBOL-NAME ELT)) CSS-CLASSES)
                       (PUSH ELT ACTUAL-CONTENTS)))
       (SETF CSS-CLASSES (REVERSE CSS-CLASSES))
       (SETF ACTUAL-CONTENTS (REVERSE ACTUAL-CONTENTS))
       (MAKE-INSTANCE 'HTML-H1
                      :CSS-CLASSES CSS-CLASSES
                      :CONTENTS ACTUAL-CONTENTS)))
   #+end_src
And....  it works!  :-)
   
** macro make-html-tag-code-generator
*** description
Some html-tags can have css-classes.  Dealing with the code-generation for the css-classes can be cumbersome AND mechanic :-/.  This macro abstracts the creation of the css-classes and the contents in strings.

And also, we are dealing with html-tags, so we need to open and close them.

This macro works if the html-tag has css-classes and contents, and maybe something else.

The idea is to be able to use something like

#+begin_src lisp
(make-html-tag-code-generator link
   (format stream "<a class='~a' href=~a>~a</a>"
           css-classes
           (gcodenil target)
           contents-string))
#+end_src

and get:

#+begin_src lisp
(defmethod generate-code ((node link) (lang undum-language) stream)
  (let* ((css-classes-string
          (if (css-classes node)
              ;; then
              (with-output-to-string (s)
                (format s "~{~a~^ ~}"
                        (css-classes node)))
              ;; else
              ""))
         (contents-string (gcodenil contents)))
    (format stream "<a class='~a' href=~a>~a</a>"
            css-classes
            (gcodenil target)
            contents-string)))
#+end_src

Let's write the macro.

*** code for the macro
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/macros.lisp
    (defmacro generate-code-for-html-tag (class-name &body body)
      "Creates the strings for css-classes and contents."
      `(defmethod generate-code ((node ,class-name) (lang undum-language) stream)
         (let* ((css-classes
                 (if (css-classes node)
                     ;; then
                     (with-output-to-string (s)
                       (format s "~{~a~^ ~}"
                               (css-classes node)))
                     ;; else
                     ""))
                (contents (gcodenil contents)))
           ,@body)))
   #+END_SRC

*** test macro expansion
   #+begin_src lisp :results none :export code 
   (generate-code-for-html-tag link
      (format stream "<a class='~a' href=~a>~a</a>"
              css-classes
              (gcodenil target)
              contents))
   #+end_src

   #+begin_src lisp
   (DEFMETHOD GENERATE-CODE ((NODE LINK) (LANG UNDUM-LANGUAGE) STREAM)
     (LET* ((CSS-CLASSES
             (IF (CSS-CLASSES NODE)
                 (WITH-OUTPUT-TO-STRING (S)
                   (FORMAT S "~{~a~^ ~}" (CSS-CLASSES NODE)))
                 ""))
            (CONTENTS (GCODENIL CONTENTS)))
       (FORMAT STREAM "<a class='~a' href=~a>~a</a>" CSS-CLASSES (GCODENIL TARGET)
               CONTENTS)))
   #+end_src

   Let's test it with actual html-tags

** macro make-basic-html-tag-code-generator
*** description
We'll call an html-tag a basic-html-tag if it only contains contents and css-classes.

The code generation for this elements is very simple.

We only need the name of the class and the string of the html-tag.

With that information we could write something like:

=(make-basic-html-tag-code-generator html-h1 "h1")=

and get:

#+begin_src lisp
(defmethod generate-code ((node html-h1) (lang undum) stream)
   (format stream "<h1 class='~a'>~a</h1>"
           (if (css-classes node) (with-output-to-string (s)
                                    (format s "~{~a~^ ~}"
                                            (css-classes node)))
               "")
           (contents node)))
#+end_src

Let's write the macro.

*** code for the macro
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/macros.lisp
   (defmacro generate-code-for-simple-html-tag (class-name html-tag)
     "Writes the generate-code method for simple-html-tag (only contents and css-classes)."
     `(defmethod generate-code ((node ,class-name) (lang undum-language) stream)
        (format stream "<~a class='~a'>~a</~a>"
                ,html-tag
                (if (css-classes node)
                    (with-output-to-string (s)
                      (format s "~{~a~^ ~}"
                              (css-classes node)))
                    ;; else
                    "")
                (gcodenil contents)
                ,html-tag)))
   #+END_SRC

*** test macro expansion
   #+begin_src lisp :results none :export code 
   (generate-code-for-simple-html-tag html-h1 "h1")
   #+end_src

   #+begin_src lisp
   (DEFMETHOD GENERATE-CODE ((NODE HTML-H1) (LANG UNDUM-LANGUAGE) STREAM)
     (FORMAT STREAM "<~a class='~a'>~a</~a>" "h1"
             (IF (CSS-CLASSES NODE)
                 (WITH-OUTPUT-TO-STRING (S)
                   (FORMAT S "~{~a~^ ~}" (CSS-CLASSES NODE)))
                 "")
             (GCODENIL CONTENTS) "h1"))
   #+end_src

   Let's test it with actual html-tags


* file to load everything
** description
   In this section I'll add a file to load everything
** code
   #+begin_src lisp :results none :export code :tangle src/load-clif.lisp
   (defun fload (filename)
     (let* ((dot-string (make-string (cl:- 40 (cl:+ 3 (length filename)))
                                     :initial-element #\.)))
       (format t "Loading ~a ..." filename)
       (load filename)
       (format t "~a OK~%" dot-string)))
   (fload "src/gagm.lisp")
   (fload "src/package.lisp")
   (fload "src/utilities.lisp")
   (fload "src/macros.lisp")
   (fload "src/ast-nodes.lisp")
   (fload "src/writer-undum.lisp")
   #+end_src



* AST (the classes for a story)

** description
In this section we'll add the classes required to make a story in Undum.  (Maybe in future incarnations we'll have different exporters, but, for now, we are dealing with undum).

All the src blocks will be tangled to the file src/ast-nodes.lisp.

** add the package to the file name
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (in-package :clif)
   #+end_src

** abstract classes

*** description 
There are some elements in the AST that share elements.  The idea is to have some base classes in this section that are common to some of the elements in the AST.

*** has-contents
**** description
A base class for all the nodes in the AST that have some content
**** code
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (defnode has-contents () 
     (contents)
     :documentation "A base class for all the elements that have content.")
   #+end_src
**** no test because it is an abstract class
   
*** has-css-classes
**** description
A base class for all the nodes that represent html nodes and can have css-classes
**** code
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (defnode has-css-classes () 
     (css-classes)
     :documentation "A base class for all the elements that can have css classes.")
   #+end_src
**** no test because it is an abstract class
** actual classes
*** class basic-situation
**** description
A class to represent a basicSituation in undum.  I think that a basicSituation is just requires an id (probably a symbol) and a list of text.

**** code
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (defnode basic-situation (has-contents) 
     (id)
     :documentation "A class to represent a basic situation in undum."
     :lambda-list (id &rest contents)
     :string-obj ("basicSituation (~a): ~a" id contents))
   #+end_src
**** tests
   #+begin_src lisp :results none :export code :tangle src/tests.lisp
   (let* ((bs1 (basic-situation 'test1
                                "hello world,"
                                " my first situation"
                                ", with 3 lines"))
          (bs2 (basic-situation 'test2
                                "<h1>Un juego con una sola situación</h1>"
                                "<p>Esta es una única situación, con texto.</p>."
                                "<p>Presiona <a href='ultimo'>aquí para terminar...</a></p>")))
     (bformat t "testing the constructor for basic-situation")
     (format t "~s~%" bs1)
     (format t "~a~%" bs2))
   #+end_src

*** class link
**** description
A class to represent an hyperlink in undum.  It is essential a traditional html =aref=, so it should have the link (probably a reference to some situation id), and a text to display
**** +code v1 (with automatic constructor)+
   #+begin_src lisp :results none
   (defnode link (has-contents has-css-classes) 
     (target)
     :documentation "A class to represent a link in undum."
     :string-obj ("<<link ~a to (~a): ~a>>" css-classes target contents))
   #+end_src
**** code v2 (with make-html-tag-constructor)
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (defnode link (has-contents has-css-classes) 
     (target)
     :documentation "A class to represent a link in undum."
     :string-obj ("<<link ~a to (~a): ~a>>" css-classes target contents))

   (make-html-tag-constructor link (target &rest contents)
     (make-instance 'link
                    :target target
                    :css-classes css-classes
                    :contents actual-contents))
   #+end_src
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (link "test1" "click here to go to 'test1"))
          (l2 (link "test2" :transient "click here to go to 'test2"))
          (l3 (link "test2" :transient "click here to go" " to 'test2" " with list"))
          (l4 (link "test2" :transient "click here to go" :another_class " to 'test2" " with list")))
     (bformat t "testing the constructor for link")
     (format t "~a~%" l1)
     (format t "~a~%" l2)
     (format t "~a~%" l3)
     (format t "~a~%" l4))
   #+end_src

*** class newline-in-undum
**** description
A class to represent an newline in the js code in undum.  It is there only to make the exported .js file more readable.
**** code
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (defnode newline-in-js-class () 
     ()
     :documentation "A class to represent a new line in the js code."
     :ctr-name nline
     :string-obj ("<<newline>>"))
   #+end_src
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (nline)))
     (bformat t "testing the constructor for newline-in-js-class")
    (format t "~a~%" l1))
   #+end_src

*** class story
**** description
A class to represent a story.  So far (2024-10-25) the story only has a list of =basic-situations=, an initial situation and...  that's all.  Obviously, there are a lot of things missing from that story, but so far, we can deal with that.
**** code
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (defnode story-class () 
     (situations initial-situation)
     :documentation "A class to represent a story."
     :ctr-name story)

   (defmethod print-object ((node story-class) stream)
     (format stream "<<A story with ~a situations>>"
             (length (situations node))))
   #+end_src
**** tests
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ((bs1 (basic-situation "start"
                                   "<h1>Un juego con una sola situación</h1>"
                                   (nline)
                                   "<p>Esta es una única situación, con texto.</p>"
                                   (nline)
                                   "<p>Presiona " (link 'ultimo "aquí para terminar.") "</p>"))
             (bs2 (basic-situation "ultimo"
                                   "<p class='transient'>Felicitaciones</p>"
                                   (nline)
                                   "<p>Has terminado tu primera aventura</p>"
                                   "<p>FIN</p>"))
             (story1 (story (list bs1 bs2) "start")))
        (bformat t "Testing story")
        (format t "~a~%" story1))
      #+end_src
*** class html-h1
**** description
A class to represent a <h1> tag in html.  The idea is to be able to write almost everything in common lisp.

As we added the class =has-css-classes= we need to create a hand-made constructor for those clases.
**** code
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (defnode html-h1 (has-contents has-css-classes)  
     ()
     :documentation "A class to represent a <h1> tag in html."
     :string-obj ("<<H1 ~a: ~a>>" css-classes contents))

   (make-simple-html-tag-constructor h1 html-h1)
   #+end_src
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (h1 "This is a test for a header"))
          (l2 (h1 "This is a test" " for a header" " with list as contents"))
          (l3 (h1 :transient "This is a test"))
          (l4 (h1 :transient "This is a test" :with_2_classes " with css-classes")))
     (bformat t "testing the constructor for p")
     (format t "~a~%" l1)
     (format t "~a~%" l2)
     (format t "~a~%" l3)
     (format t "~a~%" l4))
   #+end_src

*** class html-p
**** description
A class to represent a <p> tag in html.  The idea is to be able to write almost everything in common lisp.
**** code
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (defnode html-p (has-contents has-css-classes) 
     ()
     :documentation "A class to represent a <p> tag in html."
     :string-obj ("<<p ~a: ~a>>" css-classes contents))

   (make-simple-html-tag-constructor p html-p)
   #+end_src
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (p "This is a test for a paragraph"))
          (l2 (p "This is a test" " for a paragraph" " with a list as content"))
          (l3 (p :transient "This is a test"))
          (l4 (p :transient "This is a test" :with_2_classes " with css-classes")))
     (bformat t "testing the constructor for p")
     (format t "~a~%" l1)
     (format t "~a~%" l2)
     (format t "~a~%" l3)
     (format t "~a~%" l4))
   #+end_src

      
* code generation
** description
   In this section we add the code for the code-generation of the elements defined in the section AST.  So far (2024-10-25), we'll only export to undum, but in a future that may change.

** language undum
*** description
    In this section I'll add the code-generation routines for undum.  The src blocks will be tangled to writer-undum.lisp.

*** add the package to the file
    #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-undum.lisp
    (in-package :clif)
    #+END_SRC

*** define the undum class
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-undum.lisp
     (defnode undum-language ()
       ()
       :documentation "A class to represent the undum system.")
     #+END_SRC
**** constant
     #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-undum.lisp
     (defparameter undum (undum-language))
     #+END_SRC
**** no test because there is nothing to test :-(
**** initialization for the system
***** description
An undum "game" is made of two elements: a .js file with the situations and an html file, that is used to visualize the logic in the js.

This function genarates the html file needed for the game.  In a first iteration we are going to just duplicate the file that comes with undum.

Maybe in a future, I'll add a configuration file, where we can change some of these things.

There are some things that we changed from the original undum.

The first one is that now, the files undum.js, undum.css and jquery.js, and game.js should be in the same directory as the html file.

In the undum.css there are some images that are stored in a folder named img, that should also be on the same directory as everything else.

Maybe later, we can think of a better design for that, but so far, this are the facts.

Actually, I'm going to add those files to a folder assets in the git repository.

In fact, an actual initialize-system function should create the html AND copy all those elements to wherever the story si going to be held.  But, those are problems for the future.

***** code
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (defmethod initialize-undum (obj (lang undum-language) stream)
        "This is taken verbatim from a slightly modified version of the html that comes with the undum tutorial."

        ;; first the declaration of the doctype
        (format stream "<!DOCTYPE HTML>~%")

        ;; here we start the  html tag
        (format stream "<html lang=\"en\">")

        ;; let's write the head
        (format stream "
        <head>
          <meta charset=\"utf-8\">
          <!-- Game Title: edit this -->
          <title>Undum with Common Lisp</title>
          <!-- End of Game Title -->

          <!-- This is your game's stylesheet, modify it if you like. -->
          <link media=\"screen\"
                rel=\"stylesheet\" href=\"undum.css\">

          <!-- Suppport for mobile devices. -->
          <meta name=\"viewport\" content=\"user-scalable=no, width=device-width\">
          <link rel=\"apple-touch-icon\" href=\"media/img/iphone/icon.png\">
          <link rel=\"apple-touch-startup-image\" href=\"media/img/iphone/splash.png\">
          <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">
          <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\">
          <!--[if !IE]>-->
          <link media=\"only screen and (max-width: 640px)\"
                rel=\"stylesheet\" type=\"text/css\" href=\"media/css/undum-mobile.css\">
          <!--<![endif]-->

        </head>
      ")

        ;; let's open the body tag
        (format stream "
        <body>
      ")

        ;; the toolbar for the mobile devices
        ;; it contains a short description of the title
        (format stream "
          <!-- This isn't needed and isn't visible in desktop versions,
               because we can display the character information and the
               tools onscreen all the time. -->
          <div id=\"toolbar\">
            <!-- Set this to be a small version of the title, for the
                 toolbar on mobile devices. -->
            <h1>Learning Undum</h1>
            <div class=\"nav\">
              <a href=\"#\" class=\"button\" id=\"menu-button\">Menu</a>
            </div>
          </div>
      ")

        ;; let's open the div page
        (format stream "
          <div id=\"page\">
      ")

        ;; now the text that appears on the left
        (format stream "
            <div id=\"tools_wrapper\">
      ")

        ;; the following information is dependent on the story
        ;; and maybe in a future, we'll need to modify it
        ;; in the original html said: Game background edit this
        ;; this may be the info_panel
        (format stream "
              <div id=\"info_panel\" class=\"tools left\">
                <!-- Game Background: edit this -->
                <h1>Undum</h1>
                <p>
                  ESTE EL CÓDIGO QUE APARECE A LA IZQUIERDA
                </p>
                <!-- End of Game Background -->

                <div class='buttons'>
                  <button id=\"save\">Save</button><button id=\"erase\">Erase</button>
                </div>
              </div>
      ")

        ;; now comes the character panel
        (format stream "
              <div id=\"character_panel\" class=\"tools right\">
                <h1>Cosas del personaje</h1>
                <div id=\"character\">
                  <div id=\"character_text\">
                    <div id=\"character_text_content\"></div>
                  </div>
                  <div id=\"qualities\"></div>
                </div>
              </div>
      ")

        ;; let's cdloe the div.tools_wrapper
        (format stream "      </div> <!-- End of div.tools_wrapper -->
      ")

        ;; now, the mid_panel
        ;; there is some info related to the game
        ;; in this portion of the html
        (format stream "
            <div id=\"mid_panel\">
              <div id=\"title\">
                <div class=\"label\">

                  <!-- Game Title: edit this -->
                  <h1>Mi primera historia con undum <span>&amp;</span><br>
                    Interactive Example</h1>
                  <h2>por @fernan2rodriguez</h2>
                  <!-- End of Game Title -->

                  <noscript><p class=\"noscript_message\">This game requires 
                    Javascript.</p></noscript>
                  <p class=\"click_message\">click to begin</p>
                </div>
              </div>
      ")

        ;; the content wrapper
        (format stream "
              <div id=\"content_wrapper\">
                <div id=\"content\">
                </div>
                <a name=\"end_of_content\"></a>
              </div>
      ")

        ;; the legal part
        (format stream "
              <div id=\"legal\">
                <!-- Your Copyright: edit this -->
                <p>Estas son las cosas de copyright.</p>
                <!-- End of Your Copyright -->

                <!-- This line is totally optional. -->
                <p>Created with <a href=\"http://idmillington.github.io/undum/\">Undum</a>.</p>
              </div>")

        ;; let's close the div for the midpanel
        (format stream "
            </div>")

        ;; let's close the div page
        (format stream "
          </div> <!-- End of div.page -->
      ")


        ;; now, let's add the UI elements
        (format stream "
          <!-- Holds UI elements that will be cloned and placed in the main
               page. This block itself is always hidden. -->
          <div id=\"ui_library\">
            <div id=\"quality\" class=\"quality\">
              <span class=\"name\" data-attr=\"name\"></span>
              <span class=\"value\" data-attr=\"value\"></span>
            </div>

            <div id=\"quality_group\" class=\"quality_group\">
              <h2 data-attr=\"title\"></h2>
              <div class=\"qualities_in_group\">
              </div>
            </div>

            <div id=\"progress_bar\" class=\"progress_bar\">
              <span class=\"name\" data-attr=\"name\"></span>
              <span class=\"value\" data-attr=\"value\"></span>
              <div class=\"progress_bar_track\">
                <div class=\"progress_bar_color\" data-attr=\"width\">
                </div>
              </div>
              <span class=\"left_label\" data-attr=\"left_label\"></span>
              <span class=\"right_label\" data-attr=\"right_label\"></span>
            </div>

            <hr id=\"turn_separator\">
          </div>
      ")

        ;; let's load the libraries jquery.js and undum.js
        ;; right now the libraries are in the same directory
        ;; as the original story
        (format stream "
          <!-- Load the libraries we depend on -->
          <script type=\"text/javascript\" src=\"jquery-2.1.3.min.js\"></script>
          <script type=\"text/javascript\" src=\"undum.js\"></script>
      ")

        ;; now the name of the file with our game
        ;; right now the game is supposed to be in the same
        ;; folder as the html and the name should be undum-game.js
        (format stream "
          <!-- Change the name of this file. It is your main game file. -->
          <script type=\"text/javascript\"
                  src=\"undum-game.js\">
          </script>")

        ;; let's close the body tag
        (format stream "
        </body>
      ")


        ;; and finally, we close the html tag
        (format stream "</html>")

        )
      #+end_src

***** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ())

        (bformat t "testing initialize-undum. check /tmp/clif.html")
        (with-open-file (f "/tmp/clif.html" :direction :output
                           :if-exists :supersede)
          (initialize-undum t undum f)))
      #+end_src

      #+RESULTS:
      : ================================================
      :  testing initialize-undum. check /tmp/clif.html
      : ================================================
      : 

** code generation for undum
*** generation of basic elements (maybe this should be in gagm?)
**** description
In this section we define the code generation for the basic elements as numbers, strings and symbols
**** number
***** code
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (defmethod generate-code ((obj number) (lang undum-language) stream)
        (format stream "~a" obj))
      #+end_src
***** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (generate-code 4 undum t)
      #+end_src
**** string
***** code
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (defmethod generate-code ((obj string) (lang undum-language) stream)
        (format stream "~a" obj))
      #+end_src
***** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (generate-code "hello world!" undum t)
      #+end_src

**** symbol
***** code
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (defmethod generate-code ((obj symbol) (lang undum-language) stream)
        (format stream "~a" (symbol-name obj)))
      #+end_src
***** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (generate-code 'hello-world undum t)
      #+end_src
**** list
***** code
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (defmethod generate-code((node list)
                               (lang undum-language)
                               stream)
        (format stream "~{~a~}"
                (mapcar (lambda (x) (gcodenil-exp x))
                        node)))
      #+end_src
***** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (generate-code (list 'hello-world 1 "two") undum t)
      (generate-code nil undum t)
      #+end_src
**** nil
***** description
When we receive a nil, don't write anything
***** code
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (defmethod generate-code((node (eql nil))
                               (lang undum-language)
                               stream)
        (format stream ""))
      #+end_src
***** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (generate-code nil undum t)
      #+end_src

*** basic-situation
**** description
In this section we define how to generate code for a basic-situation.
**** code
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (defmethod generate-code ((obj basic-situation) (lang undum-language) stream)
        (format stream
      "    ~a: new undum.SimpleSituation(
               \"~{~a~}\"
          )"
      (id obj)
      (mapcar (lambda (x) (generate-code x lang nil)) (contents obj))))
      #+end_src
**** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ((bs1 (basic-situation 'test1
                                   "hello world,"
                                   " my first situation"
                                   ", with 3 lines"))
             (bs2 (basic-situation 'test2
                                   "<h1>Un juego con una sola situación</h1>"
                                   "<p>Esta es una única situación, con texto.</p>."
                                   "<p>Presiona <a href='ultimo'>aquí para terminar...</a></p>")))
        (bformat t "testing generate-code for basic situation")
        (generate-code bs1 undum t)
        (terpri) (terpri)
        (generate-code bs2 undum t))
      #+end_src

      #+RESULTS:
      : <a href='START'>al comienzo otra vez...</a>

*** link
**** description
In this section we define how to generate code for a link.
**** +code v1 (with gcode: no css-classes)+
      #+begin_src lisp :results none 
      (gcode link undum-language ("<a href='~a'>~a</a>") (target contents))
      #+end_src
**** code v2 (with macro generate-code-for-html-tag)
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (generate-code-for-html-tag link
         (format stream "<a class='~a' href='~a'>~a</a>"
                 css-classes
                 (gcodenil target)
                 contents))
      #+end_src
**** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ((l1 (link "test1" "click here to go to 'test1"))
                (l2 (link "test2" :transient "click here to go to 'test2"))
                (l3 (link "test3" :transient "click here to go" " to 'test2" " with list"))
                (l4 (link "test4" :transient "click here to go" :another_class " to 'test2" " with list")))
        (bformat t "testing the code-generation for link")
        (generate-code l1 undum t) (terpri)
        (generate-code l2 undum t) (terpri)
        (generate-code l3 undum t) (terpri)
        (generate-code l4 undum t) (terpri))
      #+end_src

      #+RESULTS:
      : <a href='START'>al comienzo otra vez...</a>

*** newline-in-js-class
**** description
In this section we define how to generate code for a newline-in-js
**** code
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (defmethod generate-code ((obj newline-in-js-class) (lang undum-language) stream)
        (format stream "\\~%"))
      #+end_src
**** test
***** simple test1
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (generate-code (nline) undum t)
      #+end_src
***** test within a situation
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ((bs1 (basic-situation "start"
                                   "<h1>Un juego con una sola situación</h1>"
                                   (nline)
                                   "<p>Esta es una única situación, con texto.</p>"
                                   (nline)
                                   "<p>Presiona " (link 'ultimo "aquí para terminar.") "</p>"))
             (bs2 (basic-situation "ultimo"
                                   "<p class='transient'>Felicitaciones</p>"
                                   (nline)
                                   "<p>Has terminado tu primera aventura</p>"
                                   (nline)
                                   "<p>FIN</p>")))
        (bformat t "testing generate-code for story")
        (generate-code bs1 undum t)
        (terpri) (terpri)
        (generate-code bs2 undum t))
      #+end_src

*** story
**** description
In this section we define how to generate code for a story.  This means to create the whole .js file.
**** code
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (defmethod generate-code ((obj story-class) (lang undum-language) stream)
        "This is taken verbatim from the .js file that comes with the example in undum."

        ;; first the initial comment
        (format stream "// ---------------------------------------------------------------------------
      // Edit this file to define your game. It should have at least four
      // sets of content: undum.game.situations, undum.game.start,
      // undum.game.qualities, and undum.game.init.
      // ---------------------------------------------------------------------------
      ")

        ;; now the game id
        (format stream "
      /* A unique id for your game. This is never displayed. I use a UUID,
       ,* but you can use anything that is guaranteed unique (a URL you own,
       ,* or a variation on your email address, for example). */
      undum.game.id = \"be1c95b9-cbc7-48c6-8e6a-89837aa9113e\";
      ")

        ;; the version of the game
        (format stream "
      /* A string indicating what version of the game this is. Versions are
       ,* used to control saved-games. If you change the content of a game,
       ,* the saved games are unlikely to work. Changing this version number
       ,* prevents Undum from trying to load the saved-game and crashing. */
      undum.game.version = \"1.0\";
      ")

        ;; the variables that control the visualization (so far they are hardcoded)

        (format stream "
      /* A variable that changes the fade out speed of the option text on
       ,* a mobile. */
      undum.game.mobileHide = 2000

      /* A variable that changes the options fade out speed. */
      undum.game.fadeSpeed = 1500

      /* A variable that changes the slide up speed after clicking on an
       ,* option. */
      undum.game.slideUpSpeed = 500
      ")

        ;; now come the situations
        ;; first, we add the comment
        (format stream "
      /* The situations that the game can be in. Each has a unique ID. */
      ")

        (format stream "undum.game.situations = {~%")

        ;; let's add the situations from the slot in the class
        ;; first, we add the first situation
        (generate-code (first (situations obj)) lang stream)

        ;; now we add the rest of the situations
        ;; separated by a comma

        (loop for situation in (rest (situations obj)) doing
              ;; first, let's add the comma
              ;; and two new lines
              (format stream ",~2%")
              ;; now let's add the next situation
              (generate-code situation lang stream)
              )

        ;; let's close the situations brackets
        ;; and add a semicolon
        (format stream "~%};~%")

        ;; let's add the id of the starting situation
        (format stream "
      // ---------------------------------------------------------------------------
      /* The Id of the starting situation. */
      undum.game.start = \"~a\";
      " (initial-situation obj))

        ;; this is the place to define the qualities
        ;; first the comment

        (format stream "
      // ---------------------------------------------------------------------------
      /* Here we define all the qualities that our characters could
       ,* possess. We don't have to be exhaustive, but if we miss one out then
       ,* that quality will never show up in the character bar in the UI. */
      ")

        ;; and now we define the qualities
        (format stream "
      undum.game.qualities = {
          skill: new undum.IntegerQuality(
              \"Skill\", {priority:\"0001\", group:'stats'}
          ),
          stamina: new undum.NumericQuality(
              \"Stamina\", {priority:\"0002\", group:'stats'}
          ),
          luck: new undum.FudgeAdjectivesQuality( // Fudge as in the FUDGE RPG
              \"<span title='Skill, Stamina and Luck are reverently borrowed from the Fighting Fantasy series of gamebooks. The words representing Luck are from the FUDGE RPG. This tooltip is illustrating that you can use any HTML in the label for a quality (in this case a span containing a title attribute).'>Luck</span>\",
              {priority:\"0003\", group:'stats'}
          ),

          inspiration: new undum.NonZeroIntegerQuality(
              \"Inspiration\", {priority:\"0001\", group:'progress'}
          ),
          novice: new undum.OnOffQuality(
              \"Novice\", {priority:\"0002\", group:'progress', onDisplay:\"&#10003;\"}
          )
      };
      ")

        ;; the groups of the qualities
        (format stream "
      // ---------------------------------------------------------------------------
      /* The qualities are displayed in groups in the character bar. This
       ,* determines the groups, their heading (which can be null for no
       ,* heading) and ordering. QualityDefinitions without a group appear at
       ,* the end. It is an error to have a quality definition belong to a
       ,* non-existent group. */
      undum.game.qualityGroups = {
          stats: new undum.QualityGroup(null, {priority:\"0001\"}),
          progress: new undum.QualityGroup('Progress', {priority:\"0002\"})
      };
      ")

        ;; the function that is run at the begining of the game
        (format stream "
      // ---------------------------------------------------------------------------
      /* This function gets run before the game begins. It is normally used
       ,* to configure the character at the start of play. */
      undum.game.init = function(character, system) {
          character.qualities.skill = 12;
          character.qualities.stamina = 12;
          character.qualities.luck = 0;
          character.qualities.novice = 1;
          character.qualities.inspiration = 0;
          system.setCharacterText(\"<p>You are starting on an exciting journey.</p>\");
      };")
  
        )
      #+end_src
**** test
***** test within a story
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ((bs1 (basic-situation "startup"
                                   "<h1>Un juego con una sola situación</h1>"
                                   (nline)
                                   "<p>Esta es una única situación, con texto.</p>"
                                   (nline)
                                   "<p>Presiona " (link 'ultimo "aquí para terminar.") "</p>"))
             (bs2 (basic-situation "ultimo"
                                   "<p class='transient'>Felicitaciones</p>"
                                   (nline)
                                   "<p>Has terminado tu primera aventura</p>"
                                   (nline)
                                   "<p>FIN</p>"))
             (story1 (story (list bs1 bs2) "startup")))

        (bformat t "testing generate-code for story")
        (generate-code story1 undum t))
      #+end_src

***** test within a story to a file
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ((bs1 (basic-situation "start"
                                   "<h1>Un juego con una sola situación</h1>"
                                   (nline)
                                   "<p>Esta es una única situación, con texto.</p>"
                                   (nline)
                                   "<p>Presiona " (link "ultimo" "aquí para terminar.") "</p>"))
             (bs2 (basic-situation "ultimo"
                                   "<p class='transient'>Felicitaciones</p>"
                                   (nline)
                                   "<p>Has terminado tu primera aventura</p>"
                                   (nline)
                                   "<p>FIN</p>"))
             (story1 (story (list bs1 bs2) "start")))

        (bformat t "testing generate-code to a file for a story")
        (with-open-file (f "/tmp/undum-game.js" :direction :output
                           :if-exists :supersede)
            (generate-code story1 undum f)))
      #+end_src

      #+RESULTS:
      : =============================================
      :  testing generate-code to a file for a story
      : =============================================
      : 

*** html-h1
**** description
In this section we define how to generate code for a h1 tag.
**** +code v1 (with gcode)+
      #+begin_src lisp :results none 
      (gcode html-h1 undum-language ("<h1 class='~a'>~a</h1>") (css-classes contents))
      #+end_src
**** +code v2 (with a generate-code method)+
      #+begin_src lisp :results none 
      (defmethod generate-code ((node html-h1) (lang undum-language) stream)
        (format stream "<h1 class='~a'>~a</h1>"
                (if (css-classes node)
                    (with-output-to-string (s)
                      (format s "~{~a~^ ~}"
                              (css-classes node)))
                    ;; else
                    "")
                (gcodenil contents)))

      #+end_src
**** code v3 (with the macro generate-code-for-simple-html-tag)
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (generate-code-for-simple-html-tag html-h1 "h1")

      #+end_src
**** test v1
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ((l1 (h1 "This is a test for a header"))
             (l2 (h1 "This is a test" " for a header" " with list as contents"))
             (l3 (h1 :transient "This is a test"))
             (l4 (h1 :transient "This is a test" :with_2_classes " with css-classes")))
        (bformat t "testing the constructor for h1")
        (generate-code l1 undum t)
        (terpri)
        (generate-code l2 undum t)
        (terpri)
        (generate-code l3 undum t)
        (terpri)
        (generate-code l4 undum t))
      #+end_src

      #+RESULTS:
      : <h1>This is a test for a header</h1>

*** html-p
**** description
In this section we define how to generate code for a p
**** +code v1 (with gcode)+
      #+begin_src lisp :results none
      (gcode html-p undum-language ("<p>~a</p>") (contents))
      #+end_src
**** code v2 (with macro generate-code-for-simple-html-tag)
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (generate-code-for-simple-html-tag html-p "p")
      #+end_src
**** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ((l1 (p "This is a test for a paragraph"))
             (l2 (p "This is a test" " for a paragraph" " with list as contents"))
             (l3 (p :transient "This is a test"))
             (l4 (p :transient "This is a test" :with_2_classes " with css-classes")))
        (bformat t "testing the code generation for <p>")
        (generate-code l1 undum t)
        (terpri)
        (generate-code l2 undum t)
        (terpri)
        (generate-code l3 undum t)
        (terpri)
        (generate-code l4 undum t))
      #+end_src

      #+RESULTS:
      : <h1>This is a test for a header</h1>


* example to test a story
** description
In this section I'm going to have story written in clif.  This will be the main test for clif :-)

All the code blocks in this section will be tangled to the file test.lisp.
** test2 (using some html elements p and h1, with css-classes)
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* (start
          last
          story1)
     (bformat t "testing a full story")
     (setf start (basic-situation
                  "start"
                  (h1 "A game with only one situation, but with h1 and p and css")
                  (nline)
                  (p "This is the only situation, with text.")
                  (nline)
                  (p :transient "And this should dissapear...  :-o")
                  (nline)
                  (p :transient "Click" (link "last"" here to end..."))))

     (setf last (basic-situation
                 "last"
                 (p "Congratulations.")
                  (nline)
                 (p "You finished your first adventure.")
                  (nline)
                 (p "THE END")))
     (setf story1 (story (list start last) "start"))
     (format t "~a~%" start)
     (format t "~a~%" last)
     (with-open-file (f "/tmp/undum-game.js"
                        :direction :output
                        :if-exists :supersede)
       (generate-code story1 undum f)))
   #+end_src

   #+RESULTS:
   #+begin_example
   ======================
    testing a full story
   ======================

   basicSituation (start): (<<H1 NIL: (A game with only one situation, but with h1 and p and css)>>
                            <<newline>>
                            <<p NIL: (This is the only situation, with text.)>>
                            <<newline>>
                            <<p (transient): (And this should dissapear...  :-o)>>
                            <<newline>>
                            <<p (transient): (Click
                                              <<link NIL to (last): ( here to end...)>>)>>)
   basicSituation (last): (<<p NIL: (Congratulations.)>> <<newline>>
                           <<p NIL: (You finished your first adventure.)>>
                           <<newline>> <<p NIL: (THE END)>>)
   #+end_example

** test1 (very elemental)
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* (start
          last)
     (bformat t "testing a full story")
     (setf start (basic-situation
                  'start
                  (list "<h1>Un juego con una sola situación</h1>"
                        "<p>Esta es una única situación, con texto.</p>."
                        "<p>Presiona" (link 'ultimo "aquí para terminar...")"</p>")))

     (setf last (basic-situation
                 'last
                 (list "<p class='transient'>Felicitaciones.</p>."
                       "<p>Has terminado tu primera aventura.</p>"
                       "<p>FIN</p>")))
     (format t "~a~%" start)
     (format t "~a~%" last))
   #+end_src

   

   
