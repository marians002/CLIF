#+title: clif: The common lisp interactive fiction system
#+AUTHOR: Fernando Raul Rodriguez Flores
#+AUTHOR: Marian S. √Ålvarez Suri

#+TODO: HERE TODO | DONE

* Description
  In this file I'm going to write (in a literate programming style) the source code for clif: The common lisp interactive fiction system.

  Clif is a language designed for the creation of choose your own adventure stories.  The goal is to use them in the writing of the conferences of  mathematical courses.
  
  After the story is written in clif it will be possible to export it to several backends.  In the beginning, we are only going to use one backend: undum.

  We are going to use the library gagm.


* package definition

** description
   In this section we define the package for clif.
   
   So far (2024-10-23), we are just creating the package and using gagm.  We are not shadowing any symbols (for now).
** code
   #+begin_src lisp :results none :export code :tangle src/package.lisp
   (defpackage :clif
     (:use :cl :gagm))
   #+end_src


   

* utilities
** description
   In this section I'll add some basic utilities that will be used all over the system.

** declare the package in utilities.lisp
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/utilities.lisp
   (in-package :clif)
   #+END_SRC

** symb,flatten and make-keyword
   
The first two utilities are symb and flatten.  The first one allows us to create symbols (useful for macro definitions), and flatten receives a tree and returns a flattened version of it.  It is useful in some macros.

*** mkstr and symb

   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/utilities.lisp
   (defun mkstr (&rest args)
     "Returns a string with the concatenation of the args"
     (string-upcase
      (with-output-to-string (s)
        (dolist (a args) (princ a s)))))

   (defun symb (&rest args)
     "Returns a symbol formed by the concatenation of the args."
     (values (intern (apply #'mkstr args))))
   #+END_SRC

*** flatten
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/utilities.lisp
    (defun flatten (x)
      "Flattens a structure."
      (labels ((rec (x acc)
                 (cond ((null x) acc)
                       ((atom x) (cons x acc))
                       (t (rec (car x) (rec (cdr x) acc))))))
        (rec x nil)))
    #+END_SRC    

*** make-keyword
    The idea is to create a keyword like =:name=.

    To make a keyword you just need to insert the symbol into the =:keyword= package.

    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/utilities.lisp
    (defun make-keyword (&rest args)
      (values (intern (apply #'mkstr args) :keyword)))
    #+END_SRC
    
** format-boxed
*** description
    This is a function very similar to format, but it prints two lines of `=', one above the format string and the other below.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/utilities.lisp
   (defun format-boxed (stream format-str &rest format-args)
     (let* ((string-to-print
             (if format-args
                 (apply 'format `(nil ,format-str ,@format-args))
                 (funcall 'format nil format-str)))
            (length (cl:+ 2 (length string-to-print)))
            (=-line (make-string length :initial-element #\=)))
       (format stream "~a~% ~a~%~a~2%"
               =-line string-to-print =-line)))

   (setf (symbol-function 'bformat) #'format-boxed)
   #+END_SRC   

** emacs-utils
*** description
    In this section I'll add the utilities to work with emacs.
*** code
   #+BEGIN_SRC emacs-lisp :results none :exports code :tangle src/emacs-utils.el
   ;; key to insert (load everything.lisp) in the repl
   (define-key lisp-mode-map (kbd "M-m M-o M-l")
     (lambda ()
       (interactive)
       (insert "(load \"src/load-clif.lisp\") (in-package :clif)")))
   #+END_SRC
   

* macros
** documentation
In this section I'll add the macros that will be used in the code.  All src blocks will be tangled to src/macros.lisp
** add the package to the file
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/macros.lisp
   (in-package :clif)
   #+END_SRC
** macro make-html-tag-constructor
*** description
The idea with this macro, is that when we create the constructor for an html-tag we need to separate the keywords in the content, that will represent the css-classes.  

We do that with a couple of loops, but I want to abstract that, because I did it twice already (for h1 and p) :grim:, and I need a third one (for link), so It is more than two times, which is the rule of thumb, so...  let's write that macro :-).

The idea (so far) is to be able to write something like:

#+begin_src lisp
(make-html-tag-constructor h1 (&rest contents)
  (make-instance 'html-h1
                 :css-classes css-classes
                 :contents actual-contents))
#+end_src

I want to leave it there, and not optimize it more, because I don't know if some other tags will need more parameters...  

The idea is:

#+begin_src lisp
(make-html-tag-constructor ctr-name lambda-list
  @body  ;; where you'll have css-classes and actual-contents
  ;; maybe you want to further process some of those lists
  ;; or I don't know :shrugs:
 )
#+end_src

Here is the hand-coded expected result:

   #+begin_src lisp :results none :export code 
   (defun h1 (&rest contents)
     (let* (css-classes
            actual-contents)
       ;; let's separate teh css-classes from the contents
       (loop for elt in contents
             doing
             (if (keywordp elt)
                 ;; if it is a keyword, let's store it as a downcase string 
                 (push (string-downcase (symbol-name elt)) css-classes)
                 ;; else
                 (push elt actual-contents)))
       ;; let's create the class
       (make-instance 'html-h1
                      :css-classes (reverse css-classes)
                      :contents (reverse actual-contents))))
   #+end_src

That should be the final result.

Let's code it :-)

*** code for the macro
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/macros.lisp
   (defmacro make-html-tag-constructor (ctr-name (&rest lambda-list) &body body)
     "In the lambda list there should be an argument named contents, and it should be a list."
     `(defun ,ctr-name ,lambda-list
        (let* (css-classes
               actual-contents)
          ;; let's separate teh css-classes from the contents
          (loop for elt in contents
                doing
                (if (keywordp elt)
                    ;; if it is a keyword, let's store it as a downcase string 
                    (push (string-downcase (symbol-name elt)) css-classes)
                    ;; else
                    (push elt actual-contents)))
          ;; now let's reverse the css-classes and actual-contents
          (setf css-classes (reverse css-classes))
          (setf actual-contents (reverse actual-contents))
          ;; let's create the class
          ;; that should do it the final user
          ,@body)))
   #+END_SRC

*** test macro expansion
   #+begin_src lisp :results none :export code 
   (make-html-tag-constructor h1 (&rest contents)
     (make-instance 'html-h1
                    :css-classes css-classes
                    :contents actual-contents))
   #+end_src

   #+begin_src lisp
   (DEFUN H1 (&REST CONTENTS)
     (LET* (CSS-CLASSES ACTUAL-CONTENTS)
       (LOOP FOR ELT IN CONTENTS
             DOING (IF (KEYWORDP ELT)
                       (PUSH (STRING-DOWNCASE (SYMBOL-NAME ELT)) CSS-CLASSES)
                       (PUSH ELT ACTUAL-CONTENTS)))
       (SETF CSS-CLASSES (REVERSE CSS-CLASSES))
       (SETF ACTUAL-CONTENTS (REVERSE ACTUAL-CONTENTS))
       (MAKE-INSTANCE 'HTML-H1 :CSS-CLASSES CSS-CLASSES :CONTENTS
                      ACTUAL-CONTENTS)))
   #+end_src

** macro make-simple-html-tag-constructor
*** description
This macro is similar to the previous one, but the idea is that there are some html-tags for which there is nothing else to do than to create the instance.  For those very simple situations this macro does everything.

The idea is to be able to write:

#+begin_src lisp
(make-simple-html-tag-constructor h1 html-h1)
#+end_src

And that creates everything and we get the following:

   #+begin_src lisp :results none :export code 
   (defun h1 (&rest contents)
     (let* (css-classes
            actual-contents)
       ;; let's separate teh css-classes from the contents
       (loop for elt in contents
             doing
             (if (keywordp elt)
                 ;; if it is a keyword, let's store it as a downcase string 
                 (push (string-downcase (symbol-name elt)) css-classes)
                 ;; else
                 (push elt actual-contents)))
       (setf css-classes (reverse css-classes))
       (setf actual-contents (reverse actual-contents))
       ;; let's create the class
       (make-instance 'html-h1
                      :css-classes css-classes
                      :contents actual-contents)))
   #+end_src
   
This should work, at least with the html-tags that we have right now (h1 and p).

*** code for the macro
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/macros.lisp
   (defmacro make-simple-html-tag-constructor (ctr-name class-name)
     `(make-html-tag-constructor ,ctr-name (&rest contents)
        (make-instance ',class-name
                       :css-classes css-classes
                       :contents actual-contents)))
   #+END_SRC

*** test macro expansion
   #+begin_src lisp :results none :export code 
   (make-simple-html-tag-constructor h1 html-h1)
   #+end_src
   Expands into:
   
   #+begin_src lisp
   (DEFUN H1 (&REST CONTENTS)
     (LET* (CSS-CLASSES ACTUAL-CONTENTS)
       (LOOP FOR ELT IN CONTENTS
             DOING (IF (KEYWORDP ELT)
                       (PUSH (STRING-DOWNCASE (SYMBOL-NAME ELT)) CSS-CLASSES)
                       (PUSH ELT ACTUAL-CONTENTS)))
       (SETF CSS-CLASSES (REVERSE CSS-CLASSES))
       (SETF ACTUAL-CONTENTS (REVERSE ACTUAL-CONTENTS))
       (MAKE-INSTANCE 'HTML-H1
                      :CSS-CLASSES CSS-CLASSES
                      :CONTENTS ACTUAL-CONTENTS)))
   #+end_src
And....  it works!  :-)
   
** macro make-html-tag-code-generator
*** description
Some html-tags can have css-classes.  Dealing with the code-generation for the css-classes can be cumbersome AND mechanic :-/.  This macro abstracts the creation of the css-classes and the contents in strings.

And also, we are dealing with html-tags, so we need to open and close them.

This macro works if the html-tag has css-classes and contents, and maybe something else.

The idea is to be able to use something like

#+begin_src lisp
(make-html-tag-code-generator link
   (format stream "<a class='~a' href=~a>~a</a>"
           css-classes
           (gcodenil target)
           contents-string))
#+end_src

and get:

#+begin_src lisp
(defmethod generate-code ((node link) (lang undum-language) stream)
  (let* ((css-classes-string
          (if (css-classes node)
              ;; then
              (with-output-to-string (s)
                (format s "~{~a~^ ~}"
                        (css-classes node)))
              ;; else
              ""))
         (contents-string (gcodenil contents)))
    (format stream "<a class='~a' href=~a>~a</a>"
            css-classes
            (gcodenil target)
            contents-string)))
#+end_src

Let's write the macro.

*** code for the macro
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/macros.lisp
    (defmacro generate-code-for-html-tag (class-name &body body)
      "Creates the strings for css-classes and contents."
      `(defmethod generate-code ((node ,class-name) (lang undum-language) stream)
         (let* ((css-classes
                 (if (css-classes node)
                     ;; then
                     (with-output-to-string (s)
                       (format s "~{~a~^ ~}"
                               (css-classes node)))
                     ;; else
                     ""))
                (contents (gcodenil contents)))
           ,@body)))
   #+END_SRC

*** test macro expansion
   #+begin_src lisp :results none :export code 
   (generate-code-for-html-tag link
      (format stream "<a class='~a' href=~a>~a</a>"
              css-classes
              (gcodenil target)
              contents))
   #+end_src

   #+begin_src lisp
   (DEFMETHOD GENERATE-CODE ((NODE LINK) (LANG UNDUM-LANGUAGE) STREAM)
     (LET* ((CSS-CLASSES
             (IF (CSS-CLASSES NODE)
                 (WITH-OUTPUT-TO-STRING (S)
                   (FORMAT S "~{~a~^ ~}" (CSS-CLASSES NODE)))
                 ""))
            (CONTENTS (GCODENIL CONTENTS)))
       (FORMAT STREAM "<a class='~a' href=~a>~a</a>" CSS-CLASSES (GCODENIL TARGET)
               CONTENTS)))
   #+end_src

   Let's test it with actual html-tags

** macro make-basic-html-tag-code-generator
*** description
We'll call an html-tag a basic-html-tag if it only contains contents and css-classes.

The code generation for this elements is very simple.

We only need the name of the class and the string of the html-tag.

With that information we could write something like:

=(make-basic-html-tag-code-generator html-h1 "h1")=

and get:

#+begin_src lisp
(defmethod generate-code ((node html-h1) (lang undum) stream)
   (format stream "<h1 class='~a'>~a</h1>"
           (if (css-classes node) (with-output-to-string (s)
                                    (format s "~{~a~^ ~}"
                                            (css-classes node)))
               "")
           (contents node)))
#+end_src

Let's write the macro.

*** code for the macro
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/macros.lisp
   (defmacro generate-code-for-simple-html-tag (class-name html-tag)
     "Writes the generate-code method for simple-html-tag (only contents and css-classes)."
     `(defmethod generate-code ((node ,class-name) (lang undum-language) stream)
        (format stream "<~a class='~a'>~a</~a>"
                ,html-tag
                (if (css-classes node)
                    (with-output-to-string (s)
                      (format s "~{~a~^ ~}"
                              (css-classes node)))
                    ;; else
                    "")
                (gcodenil contents)
                ,html-tag)))
   #+END_SRC

*** test macro expansion
   #+begin_src lisp :results none :export code 
   (generate-code-for-simple-html-tag html-h1 "h1")
   #+end_src

   #+begin_src lisp
   (DEFMETHOD GENERATE-CODE ((NODE HTML-H1) (LANG UNDUM-LANGUAGE) STREAM)
     (FORMAT STREAM "<~a class='~a'>~a</~a>" "h1"
             (IF (CSS-CLASSES NODE)
                 (WITH-OUTPUT-TO-STRING (S)
                   (FORMAT S "~{~a~^ ~}" (CSS-CLASSES NODE)))
                 "")
             (GCODENIL CONTENTS) "h1"))
   #+end_src

   Let's test it with actual html-tags
   

* file to load everything
** description
   In this section I'll add a file to load everything
** code
   #+begin_src lisp :results none :export code :tangle src/load-clif.lisp
     (defun fload (filename)
       (let* ((dot-string (make-string (cl:- 40 (cl:+ 3 (length filename)))
				       :initial-element #\.)))
	 (format t "Loading ~a ..." filename)
	 (load filename)
	 (format t "~a OK~%" dot-string)))
     (fload "src/gagm.lisp")
     (fload "src/package.lisp")
     (fload "src/utilities.lisp")
     (fload "src/macros.lisp")
     (fload "src/ast-nodes.lisp")
     (fload "src/writer-html.lisp")
     (fload "src/writer-latex.lisp")
   #+end_src



* AST (the classes for a story)

** description
In this section we'll add the classes required to make a story in Undum.  (Maybe in future incarnations we'll have different exporters, but, for now, we are dealing with undum).

All the src blocks will be tangled to the file src/ast-nodes.lisp.

** add the package to the file name
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (in-package :clif)
   #+end_src
   
** abstract classes
*** description 
There are some elements in the AST that share elements.  The idea is to have some base classes in this section that are common to some of the elements in the AST.

*** has-contents
**** description
A base class for all the nodes in the AST that have some content
**** code
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (defnode has-contents () 
     (contents)
     :documentation "A base class for all the elements that have content.")
   #+end_src
**** no test because it is an abstract class
   
*** has-css-classes
**** description
A base class for all the nodes that represent html nodes and can have css-classes
**** code
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (defnode has-css-classes () 
     (css-classes)
     :documentation "A base class for all the elements that can have css classes.")
   #+end_src
**** no test because it is an abstract class
** +actual classes+
*** class basic-situation
**** description
A class to represent a basicSituation in undum.  I think that a basicSituation only requires an id (probably a symbol) and a list of text.

**** code
   #+begin_src lisp :results none :export code 
   (defnode basic-situation (has-contents) 
     (id)
     :documentation "A class to represent a basic situation in undum."
     :lambda-list (id &rest contents)
     :string-obj ("basicSituation (~a): ~a" id contents))
   #+end_src
**** tests
   #+begin_src lisp :results none :export code :tangle src/tests.lisp
   (let* ((bs1 (basic-situation 'test1
                                "hello world,"
                                " my first situation"
                                ", with 3 lines"))
          (bs2 (basic-situation 'test2
                                "<h1>Un juego con una sola situaci√≥n</h1>"
                                "<p>Esta es una √∫nica situaci√≥n, con texto.</p>."
                                "<p>Presiona <a href='ultimo'>aqu√≠ para terminar...</a></p>")))
     (bformat t "testing the constructor for basic-situation")
     (format t "~s~%" bs1)
     (format t "~a~%" bs2))
   #+end_src

*** class link
**** description
A class to represent an hyperlink in undum.  It is essential a traditional html =aref=, so it should have the link (probably a reference to some situation id), and a text to display
**** +code v1 (with automatic constructor)+
   #+begin_src lisp :results none
   (defnode link (has-contents has-css-classes) 
     (target)
     :documentation "A class to represent a link in undum."
     :string-obj ("<<link ~a to (~a): ~a>>" css-classes target contents))
   #+end_src
**** code v2 (with make-html-tag-constructor)
   #+begin_src lisp :results none :export code 
   (defnode link (has-contents has-css-classes) 
     (target)
     :documentation "A class to represent a link in undum."
     :string-obj ("<<link ~a to (~a): ~a>>" css-classes target contents))

   (make-html-tag-constructor link (target &rest contents)
     (make-instance 'link
                    :target target
                    :css-classes css-classes
                    :contents actual-contents))
   #+end_src
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (link "test1" "click here to go to 'test1"))
          (l2 (link "test2" :transient "click here to go to 'test2"))
          (l3 (link "test2" :transient "click here to go" " to 'test2" " with list"))
          (l4 (link "test2" :transient "click here to go" :another_class " to 'test2" " with list")))
     (bformat t "testing the constructor for link")
     (format t "~a~%" l1)
     (format t "~a~%" l2)
     (format t "~a~%" l3)
     (format t "~a~%" l4))
   #+end_src

*** class newline-in-undum
**** description
A class to represent a newline in the js code in undum.  It is there only to make the exported .js file more readable.
**** code
   #+begin_src lisp :results none :export code 
   (defnode newline-in-js-class () 
     ()
     :documentation "A class to represent a new line in the js code."
     :ctr-name nline
     :string-obj ("<<newline>>"))
   #+end_src
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (nline)))
     (bformat t "testing the constructor for newline-in-js-class")
    (format t "~a~%" l1))
   #+end_src
   
*** class story
**** description
A class to represent a story.  So far (2024-10-25) the story only has a list of =basic-situations=, an initial situation and...  that's all.  Obviously, there are a lot of things missing from that story, but so far, we can deal with that.
**** code
   #+begin_src lisp :results none :export code 
   (defnode story-class () 
     (situations initial-situation)
     :documentation "A class to represent a story."
     :ctr-name story)

   (defmethod print-object ((node story-class) stream)
     (format stream "<<A story with ~a situations>>"
             (length (situations node))))
   #+end_src
**** tests
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ((bs1 (basic-situation "start"
                                   "<h1>Un juego con una sola situaci√≥n</h1>"
                                   (nline)
                                   "<p>Esta es una √∫nica situaci√≥n, con texto.</p>"
                                   (nline)
                                   "<p>Presiona " (link 'ultimo "aqu√≠ para terminar.") "</p>"))
             (bs2 (basic-situation "ultimo"
                                   "<p class='transient'>Felicitaciones</p>"
                                   (nline)
                                   "<p>Has terminado tu primera aventura</p>"
                                   "<p>FIN</p>"))
             (story1 (story (list bs1 bs2) "start")))
        (bformat t "Testing story")
        (format t "~a~%" story1))
      #+end_src
*** class html-h1
**** description
A class to represent a <h1> tag in html.  The idea is to be able to write almost everything in common lisp.

As we added the class =has-css-classes= we need to create a hand-made constructor for those clases.
**** code
   #+begin_src lisp :results none :export code 
   (defnode html-h1 (has-contents has-css-classes)  
     ()
     :documentation "A class to represent a <h1> tag in html."
     :string-obj ("<<H1 ~a: ~a>>" css-classes contents))

   (make-simple-html-tag-constructor h1 html-h1)
   #+end_src
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (h1 "This is a test for a header"))
          (l2 (h1 "This is a test" " for a header" " with list as contents"))
          (l3 (h1 :transient "This is a test"))
          (l4 (h1 :transient "This is a test" :with_2_classes " with css-classes")))
     (bformat t "testing the constructor for p")
     (format t "~a~%" l1)
     (format t "~a~%" l2)
     (format t "~a~%" l3)
     (format t "~a~%" l4))
   #+end_src

*** class html-p
**** description
A class to represent a <p> tag in html.  The idea is to be able to write almost everything in common lisp.
**** code
   #+begin_src lisp :results none :export code 
   (defnode html-p (has-contents has-css-classes) 
     ()
     :documentation "A class to represent a <p> tag in html."
     :string-obj ("<<p ~a: ~a>>" css-classes contents))

   (make-simple-html-tag-constructor p html-p)
   #+end_src
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (p "This is a test for a paragraph"))
          (l2 (p "This is a test" " for a paragraph" " with a list as content"))
          (l3 (p :transient "This is a test"))
          (l4 (p :transient "This is a test" :with_2_classes " with css-classes")))
     (bformat t "testing the constructor for p")
     (format t "~a~%" l1)
     (format t "~a~%" l2)
     (format t "~a~%" l3)
     (format t "~a~%" l4))
   #+end_src

*** class newline-in-html
**** description
A class to represent a newline in the html code. 
**** code
 #+begin_src lisp :results none :export code 
   (defnode html-br ()
       ()
       :documentation "A class to represent a line break in HTML."
       :string-obj ("<<br>>"))

   (defun br ()
     "Creates a new html-br instance."
     (make-instance 'html-br))
    #+end_src
**** tests
*** class ul
**** description
A class to represent an unordered list (<ul> tag) in html. 
**** code
#+begin_src lisp :results none :export code 
  (defnode html-ul (has-contents has-css-classes)
    ()
    :documentation "A class to represent a <ul> tag in html."
    :string-obj ("<<ul ~a: ~a>>" css-classes contents))
  (make-simple-html-tag-constructor ul html-ul)
#+end_src
**** tests
 -- tests in li
 
*** class ol
**** description
A class to represent an ordered list (<ol> tag) in html.
**** code
#+begin_src lisp :results none :export code 
  (defnode html-ol (has-contents has-css-classes)
    ()
    :documentation "A class to represent a <ol> tag in html."
    :string-obj ("<<ol ~a: ~a>>" css-classes contents))
  (make-simple-html-tag-constructor ol html-ol)
#+end_src
**** tests
-- tests in li
*** class li
**** description
A class to represent a list item (<li> tag) in html.
**** code
#+begin_src lisp :results none :export code 
  (defnode html-li (has-contents has-css-classes)
    ()
    :documentation "A class to represent a <li> tag in HTML."
    :string-obj ("<<li ~a: ~a>>" css-classes contents))

  (make-simple-html-tag-constructor li html-li)
#+end_src
**** tests
*** class button
**** description
A class to represent an html button
**** code
#+begin_src lisp :results none :export code 
 (defnode html-button (has-contents has-css-classes)
  (function-name)
  :documentation "A class to represent a button that triggers actions."
  :string-obj ("<<button ~a: ~a>>" css-classes contents))

(make-html-tag-constructor button (function-name &rest contents)
  (make-instance 'html-button
                 :function-name function-name
                 :css-classes css-classes
                 :contents actual-contents))

#+end_src

**** tests

** actual classes (2025-06-17)
*** class text
**** description
A class to represent a test.  The idea is to be able to write almost everything in common lisp.
**** code
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (defnode text (has-contents) 
     ()
     :documentation "A class to represent a block of text."
     :string-obj ("<<text: ~a>>" contents)
     :ctr-name text
     :lambda-list (&rest contents))
   #+end_src
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (text "This is a test for a paragraph"))
          (l2 (text "This is a test" " for a paragraph" " with a list as content")))
     (bformat t "testing the constructor for text")
     (format t "~a~%" l1)
     (format t "~a~%" l2))
   #+end_src

   #+RESULTS:
   : ==================================
   :  testing the constructor for text
   : ==================================
   : 
   : <<text: (This is a test for a paragraph)>>
   : <<text: (This is a test  for a paragraph  with a list as content)>>

*** class title
**** description
A class to represent a title. 
**** code
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (defnode title (has-contents) 
     ()
     :documentation "A class to represent a title."
     :string-obj ("<<title: ~a>>" contents)
     :ctr-name title
     :lambda-list (&rest contents))
   #+end_src
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (title "This is a test for a title"))
          (l2 (title "This is a test" " for a title" " with a list as content")))
     (bformat t "testing the constructor for title")
     (format t "~a~%" l1)
     (format t "~a~%" l2))
   #+end_src

   #+RESULTS:
   : ==================================
   :  testing the constructor for text
   : ==================================
   : 
   : <<text: (This is a test for a paragraph)>>
   : <<text: (This is a test  for a paragraph  with a list as content)>>
*** class subtitle
**** description
A class to represent a subtitle. 
**** code
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (defnode subtitle (has-contents) 
     ()
     :documentation "A class to represent a subtitle."
     :string-obj ("<<subtitle: ~a>>" contents)
     :ctr-name subtitle
     :lambda-list (&rest contents))
   #+end_src
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (subtitle "This is a test for a subtitle"))
          (l2 (subtitle "This is a test" " for a subtitle" " with a list as content")))
     (bformat t "testing the constructor for subtitle")
     (format t "~a~%" l1)
     (format t "~a~%" l2))
   #+end_src

   #+RESULTS:
   : ======================================
   :  testing the constructor for subtitle
   : ======================================
   : 
   : <<subtitle: (This is a test for a subtitle)>>
   : <<subtitle: (This is a test  for a subtitle  with a list as content)>>
*** class item
**** description
A class to represent a list item (<li> tag) in html.
**** code
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
  (defnode item (has-contents)
    ()
    :documentation "A class to represent an item."
    :string-obj ("<<item: ~a>>" contents)
    :lambda-list (&rest contents))
#+end_src    
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (item "Element 1"))
          (l2 (item "With a list of elements")))
     (bformat t "testing the constructor for item")
     (format t "~a~%" l1)
     (format t "~a~%" l2))
   #+end_src

   #+RESULTS:
   : ==================================
   :  testing the constructor for item
   : ==================================
   : 
   : <<item: (Element 1)>>
   : <<item: (With a list of elements)>>



#+end_src
*** class ordered-list
**** description
A class to represent an ordered list.
**** code
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
(defnode ordered-list (has-contents)
  ()
  :documentation "A class to represent an ordered lis."
  :string-obj ("<<list: ~a>>" contents)
  :ctr-name enumerate
  :lambda-list (&rest contents))
#+end_src    
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (enumerate "Element 1" "element2"))
          (l2 (enumerate (item "element1") (item "element2"))))
     (bformat t "Testing the constructor for enumerate")
     (format t "~a~%" l1)
     (format t "~a~%" l2))
   #+end_src

   #+RESULTS:
   : =======================================
   :  Testing the constructor for enumerate
   : =======================================
   : 
   : <<list: (Element 1 element2)>>
   : <<list: (<<item: (element1)>> <<item: (element2)>>)>>



#+end_src

*** class unordered-list
**** description
A class to represent an unordered list.
**** code
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
(defnode unordered-list (has-contents)
  ()
  :documentation "A class to represent an unordered lis."
  :string-obj ("<<list: ~a>>" contents)
  :ctr-name itemize
  :lambda-list (&rest contents))
#+end_src    
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (itemize "Element 1" "element2"))
          (l2 (itemize (item "element1") (item "element2"))))
     (bformat t "Testing the constructor for itemize")
     (format t "~a~%" l1)
     (format t "~a~%" l2))
   #+end_src

   #+RESULTS:
   : =====================================
   :  Testing the constructor for itemize
   : =====================================
   : 
   : <<list: (Element 1 element2)>>
   : <<list: (<<item: (element1)>> <<item: (element2)>>)>>



#+end_src

*** new-line
**** description
A class to represent a new-line
**** code
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
(defnode newline ()
  ()
  :documentation "A class to represent an ordered lis."
  :string-obj ("<<newline>>"))
#+end_src    
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (newline)))
     (bformat t "Testing the constructor for enumerate")
     (format t "~a~%" l1))
   #+end_src

   #+RESULTS:
   : =======================================
   :  Testing the constructor for enumerate
   : =======================================
   : 
   : <<newline>>

-------------------------------------------------------------
*** bold-face
**** description
A class to represent a format with bold
**** code
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
(defnode bold-face (has-contents)
  ()
  :documentation "A class to represent things formated with bold."
  :string-obj ("<<b ~a>>" contents)
  :ctr-name b
  :lambda-list (&rest contents))
#+end_src    
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (b "hola mundo")))
     (bformat t "Testing the constructor for bold")
     (format t "~a~%" l1))
   #+end_src

   #+RESULTS:
   : ==================================
   :  Testing the constructor for bold
   : ==================================
   : 
   : <<b (hola mundo)>>

*** italic-face
**** description
A class to represent a format with italic
**** code
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
(defnode italic-face (has-contents)
  ()
  :documentation "A class to represent things formated with italic."
  :string-obj ("<<it ~a>>" contents)
  :ctr-name it
  :lambda-list (&rest contents))
#+end_src    
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (it "hola mundo")))
     (bformat t "Testing the constructor for italic")
     (format t "~a~%" l1))
   #+end_src

   #+RESULTS:
   : ====================================
   :  Testing the constructor for italic
   : ====================================
   : 
   : <<it (hola mundo)>>

*** tt-face
**** description
A class to represent a format with tt or monospace
**** code
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
(defnode tt-face (has-contents)
  ()
  :documentation "A class to represent things formated with monospace."
  :string-obj ("<<tt ~a>>" contents)
  :ctr-name tt
  :lambda-list (&rest contents))
#+end_src    
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (tt "hola mundo")))
     (bformat t "Testing the constructor for monospace")
     (format t "~a~%" l1))
   #+end_src

   #+RESULTS:
   : =======================================
   :  Testing the constructor for monospace
   : =======================================
   : 
   : <<tt (hola mundo)>>

*** strike-out-face
**** description
A class to represent a format with strike out.
**** code
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
(defnode strike-face (has-contents)
  ()
  :documentation "A class to represent things formated with strike."
  :string-obj ("<<strike ~a>>" contents)
  :ctr-name strike
  :lambda-list (&rest contents))
#+end_src    
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (strike "not so hola mundo")))
     (bformat t "Testing the constructor for strike")
     (format t "~a~%" l1))
   #+end_src

   #+RESULTS:
   : ====================================
   :  Testing the constructor for strike
   : ====================================
   : 
   : <<strike (not so hola mundo)>>

*** underline-face
**** description
A class to represent a format with underline.
**** code
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
(defnode underline-face (has-contents)
  ()
  :documentation "A class to represent things formated with underline."
  :string-obj ("<<underline ~a>>" contents)
  :ctr-name underline
  :lambda-list (&rest contents))
#+end_src    
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (underline "underlined hola mundo")))
     (bformat t "Testing the constructor for underline")
     (format t "~a~%" l1))
   #+end_src

   #+RESULTS:
   : =======================================
   :  Testing the constructor for underline
   : =======================================
   : 
   : <<underline (underlined hola mundo)>>

--------------------------------------------------------------
*** link
**** description
A class to represent an hyperlink.

It is a macro so we don't have to quote the target and it can be a symbol.
**** code
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (defnode link (has-contents) 
     (target)
     :documentation "A class to represent a link."
     :string-obj ("<<link to (~a): ~a>>" target contents)
     :ctr-type macro
     :lambda-list (target &rest contents))
   #+end_src
**** tests
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (link test1 "click here to go to 'test1"))
          (l2 (link test2 "click here " "to go to 'test2")))
     (bformat t "testing the constructor for link")
     (format t "~a~%" l1)
     (format t "~a~%" l2))
   #+end_src

   #+RESULTS:
   : ==================================
   :  testing the constructor for link
   : ==================================
   : 
   : <<link to (TEST1): (click here to go to 'test1)>>
   : <<link to (test2): (click here  to go to 'test2)>>

*** action
**** description
A class to represent an action that transforms some text into some other text

Note: maybe later contents could be used to define the function code
**** code
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
  (defnode action (has-contents)
    (action-id trigger-text target-id
    contents)
    :documentation "A node that shows text when activated."
    :string-obj ("<<Action{~a}. Shows {~a} and transforms to {~a} with id {~a}." action-id trigger-text contents target-id)
    :ctr-type macro
    :lambda-list (action-id trigger-text target-id &rest contents)
   )
#+end_src
**** tests
*** image
**** description
A class to represent an image with optional alignment and size properties.
**** code
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
  (defnode image ()
      (src
       alt-text
       (align :initform nil)
       (size :initform nil))
      :documentation "A node that represents an image with optional alignment and size."
      :string-obj ("<<Image: ~a from ~a with align ~a and size ~a>>" alt-text src align size)
      :ctr-type macro
      :lambda-list (src alt-text &key align size)
      )
#+end_src
**** tests
 #+begin_src lisp :results output :export code :tangle src/tests.lisp
(let* ((l1 (image "/home/marian/Pictures/firma.jpg"
		   "mi firma"
		   :align :center
		   :size "20x3"))
	(l2 (image "/home/marian/Pictures/firma.jpg"
		   "mi firma")))
   (bformat t "testing the constructor for image")
   (format t "~a~%" l1)
   (format t "~a~%" l2))
   #+end_src

   #+RESULTS:
   : ===================================
   :  testing the constructor for image
   : ===================================
   : 
   : <<Image: mi firma from /home/marian/Pictures/firma.jpg with align CENTER and size 20x3>>
   : <<Image: mi firma from /home/marian/Pictures/firma.jpg with align NIL and size NIL>>

*** sound
**** description
A node to represent a sound.
**** code
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
(defnode start-sound ()
  (src
   (alt-text :initform "You can listen to some sound in the background"))
  :documentation "A node that represents a sound file with optional alternative text."
  :string-obj ("<<Sound: ~a from ~a>>" alt-text src)
  :ctr-type macro
  :lambda-list (src &key alt-text)
  :ctr-body `(make-instance 'start-sound
               :src ,src
               :alt-text ,(or alt-text "You can listen to some sound in the background")))
#+end_src
**** tests
 #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (start-sound "/home/marian/sound/rain.mp3"
		      :alt-text "rain in the background"))
	   (l2 (start-sound "/home/marian/sound/rain.mp3")))

      (bformat t "testing the constructor for sound")
      (format t "~a~%" l1)
      (format t "~a~%" l2))
   #+end_src

   #+RESULTS:
   : ===================================
   :  testing the constructor for sound
   : ===================================
   : 
   : <<Sound: rain in the background from /home/marian/sound/rain.mp3>>
   : <<Sound: You can listen to some sound in the background from /home/marian/sound/rain.mp3>>

*** TODO stop-sound
*** TODO change-vol-sound
*** TODO change-vol-video
*** class video
**** description
A class to represent a video
**** code
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
(defnode video ()
  (src
   (alt-text :initform "Some video content"))
  :documentation "A node that represents a video file with optional dimensions."
  :string-obj ("<<Video: ~a from ~a>>" alt-text src)
  :ctr-type macro
  :lambda-list (src &key alt-text)
  :ctr-body `(make-instance 'video
               :src ,src
               :alt-text ,(or alt-text "Some video content")))
#+end_src
---------------------------------------------------------------
*** change-bg-color
**** code
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
(defnode change-bg-color ()
 (color)
  :documentation "A node that changes the background color."
  :string-obj ("<<Change background color to ~a>>" color)
  :lambda-list (color))
#+end_src
*** change-bg-image
**** code
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
(defnode change-bg-image ()
  (image-url)
  :documentation "A node that changes the background image with default settings."
  :string-obj ("<<Change background image to ~a>>" image-url)
  :lambda-list (image-url))
#+end_src

---------------------------------------------------------------
*** font
**** description
A node to modfy the font of some text
**** code
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (defnode font (has-contents) 
     (new-font)
     :documentation "A class to represent a text with a new font type."
     :string-obj ("<<new font: ~a, Text: ~a>>" new-font contents)
     :ctr-type macro
     :lambda-list (new-font &rest contents))
   #+end_src
*** whiteboard
**** code
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
(defnode whiteboard (has-contents)
  (wb-title author)
  :documentation "A node that creates a whiteboard with title and content."
  :string-obj ("<<Whiteboard: ~a by ~a>> ~a" wb-title author contents)
  :ctr-type macro
  :lambda-list (wb-title author &rest contents)
  :ctr-body `(make-instance 'whiteboard 
               :wb-title ,wb-title
               :author ,author
               :contents (list ,@contents)))
#+end_src
**** tests
 #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* ((l1 (whiteboard "TITULO"
		      "Marian S. aaaa"
                        (text "prueba")))
	   (l2 (whiteboard "SIN TITULO JAJAJAJ" "ANONIMO")))
      (bformat t "testing the constructor for whiteboard")
      (format t "~a~%" l1)
      (format t "~a~%" l2))
   #+end_src

   #+RESULTS:
   : ========================================
   :  testing the constructor for whiteboard
   : ========================================
   : 
   : <<Whiteboard: TITULO by Marian S. aaaa>> (<<text: (prueba)>>)
   : <<Whiteboard: SIN TITULO JAJAJAJ by ANONIMO>> NIL

*** TODO clear-whiteboard
*** TODO add-to-wb
*** TODO del-whiteboard
*** TODO hide-whiteboard
*** math-inline
**** code
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
(defnode math-inline ()
  (math)
  :documentation "A node for inline mathematical expressions."
  :string-obj ("<<Math: ~a>>" math)
  :ctr-name math-inline
  :lambda-list (math))
#+end_src
*** math-center
**** code
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
(defnode math-center ()
  (math)
  :documentation "A node for centered mathematical expressions."
  :string-obj ("<<Math centered: ~a>>" math)
  :ctr-name math-center
  :lambda-list (math))
#+end_src
*** code-node
#+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
(defnode code-node ()
  (language code)
  :documentation "A node for displaying code with syntax highlighting."
  :string-obj ("<<Code block (~a): ~a>>" language code)
  :ctr-name code-node
  :lambda-list (language code))
#+end_src
*** scene
**** description
A class to represent a scene in clif.
**** code
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (defnode scene (has-contents) 
     (id)
     :documentation "A class to represent a scene."
     :ctr-type macro
     :lambda-list (id &rest contents)
     :ctr-body (let* ((scene-value (gensym)))
                 `(let* ((,scene-value (make-instance 'scene :id ',id
                                                      :contents (list ,@contents))))
                    (defparameter ,id ,scene-value)
                    ,scene-value))
     :string-obj (" <<scene (~a):~%~{  ~a~%~}" id contents))

   #+end_src
**** tests
***** testing macroexpansion
   #+begin_src lisp :results none :export code
   (scene introduccion
          (text "El comienzo")
          (text "Una escena con un "
                (link final "link al final")))
   #+end_src

***** test viejito (y que ya no sirve)
   #+begin_src lisp :results none :export code
   (let* ((bs1 (-situation 'test1
                                "hello world,"
                                " my first situation"
                                ", with 3 lines"))
          (bs2 (basic-situation 'test2
                                "<h1>Un juego con una sola situaci√≥n</h1>"
                                "<p>Esta es una √∫nica situaci√≥n, con texto.</p>."
                                "<p>Presiona <a href='ultimo'>aqu√≠ para terminar...</a></p>")))
     (bformat t "testing the constructor for basic-situation")
     (format t "~s~%" bs1)
     (format t "~a~%" bs2))
   #+end_src

*** story
**** description
A class to represent a story
**** code
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (defnode story (has-contents) 
     (id
      story-title
      (author :initform "Anonimous")
      start)
     :documentation "A class to represent a story."
     :string-obj ("<<story (~a, by ~a):~2%~{~a~2%~}" story-title author contents)
     :ctr-type macro
     :lambda-list (id (&key author story-title start) &rest contents)
     :ctr-body `(defparameter ,id (make-instance 'story
                                                 :story-title ,story-title
                                                 :author ,author
                                                 :start ,start
                                                 :contents (list ,@contents))))
   #+end_src
**** tests
***** testing macroexpansion
#+begin_src lisp
(story historia1 (:author "Mark Twain"
                  :story-title "El gato con botas"
                  :start introduccion)
       introduccion

       (scene final (text "El final")
              (text "Has llegado al final")
              (text (b "THE END"))))

#+end_src

#+RESULTS:
: HISTORIA1

***** test viejito
   #+begin_src lisp :results output :export code
   (let* ((l1 (link test1 "click here to go to 'test1"))
          (l2 (link test2 "click here " "to go to 'test2")))
     (bformat t "testing the constructor for link")
     (format t "~a~%" l1)
     (format t "~a~%" l2))
   #+end_src

   #+RESULTS:
   : ==================================
   :  testing the constructor for link
   : ==================================
   : 
   : <<link to (TEST1): (click here to go to 'test1)>>
   : <<link to (test2): (click here  to go to 'test2)>>


* code generation
** description
   In this section we add the code for the code-generation of the elements defined in the section AST.  So far (2024-10-25), we'll only export to undum, but in a future that may change.

** language old-fashion html (html puro y duro)
*** description
En este /formato de salida/ cada escena es una p√°gina web.
*** declaracion de la clase
     #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-html.lisp
     (defnode html-language ()
       ()
       :documentation "A class to represent the barebone html system.")
     #+END_SRC
**** constant
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-html.lisp
(defparameter html (make-instance 'html-language))
#+END_SRC
*** generation of basic elements (maybe this should be in gagm?  S√ç >:-|)
**** description
In this section we define the code generation for the basic elements as numbers, strings and symbols
**** number
***** code
      #+begin_src lisp :results none :export code :tangle src/writer-html.lisp
      (defmethod generate-code ((obj number) (lang html-language) stream)
        (format stream "~a" obj))
      #+end_src
***** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (generate-code 4 html t)
      #+end_src

      #+RESULTS:
      : 4

**** string
***** code
      #+begin_src lisp :results none :export code :tangle src/writer-html.lisp
      (defmethod generate-code ((obj string) (lang html-language) stream)
        (format stream "~a" obj))
      #+end_src
***** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (generate-code "hello world!" html t)
      #+end_src

      #+RESULTS:
      : hello world!

**** symbol
***** code
      #+begin_src lisp :results none :export code :tangle src/writer-html.lisp
      (defmethod generate-code ((obj symbol) (lang html-language) stream)
        (format stream "~a" (symbol-name obj)))
      #+end_src
***** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (generate-code 'hello-world html t)
      #+end_src

      #+RESULTS:
      : HELLO-WORLD

**** list
***** code
      #+begin_src lisp :results none :export code :tangle src/writer-html.lisp
      (defmethod generate-code((node list)
                               (lang html-language)
                               stream)
        (format stream "~{~a~}"
                (mapcar (lambda (x) (gcodenil-exp x))
                        node)))
      #+end_src
***** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (generate-code (list 'hello-world 1 "two") html t)
      (generate-code nil html t)
      #+end_src
**** nil
***** description
When we receive a nil, don't write anything
***** code
      #+begin_src lisp :results none :export code :tangle src/writer-html.lisp
      (defmethod generate-code((node (eql nil))
                               (lang html-language)
                               stream)
        (format stream ""))
      #+end_src
***** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (generate-code nil html t)
      #+end_src

*** generaci√≥n para cada nodo
**** text
***** code
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-html.lisp
(gcode text html-language ("<p>~a</p>") (contents))
#+END_SRC
***** test
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/tests.lisp
(let* ((l1 (text "hola mundo")))
  (generate-code l1 html t))
#+END_SRC
**** title
***** code
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-html.lisp
(gcode title html-language ("<h1>~a</h1>") (contents))
#+END_SRC
***** test
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/tests.lisp
(let* ((l1 (title "Titulo de ejemplo")))
  (generate-code l1 html t))
#+END_SRC
**** subtitle
***** code
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-html.lisp
(gcode subtitle html-language ("<h2>~a</h2>") (contents))
#+END_SRC
***** test
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/tests.lisp
(let* ((l6 (subtitle "Subtitulo de ejemplo")))
  (generate-code l6 html t))
#+END_SRC
**** bold-face
***** code
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-html.lisp
(gcode bold-face html-language ("<b>~a</b>") (contents))
#+END_SRC
***** test
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/tests.lisp
(let* ((l1 (b "hola mundo")))
  (generate-code l1 html t))
#+END_SRC
**** italic-face
***** code
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-html.lisp
(gcode italic-face html-language ("<i>~a</i>") (contents))
#+END_SRC
***** test
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/tests.lisp
(let* ((l2 (it "texto en italica")))
  (generate-code l2 html t))
#+END_SRC
**** tt-face
***** code
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-html.lisp
(gcode tt-face html-language ("<tt>~a</tt>") (contents))
#+END_SRC
***** test
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/tests.lisp
(let* ((l3 (tt "text for code")))
  (generate-code l3 html t))
#+END_SRC
**** strike-face
***** code
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-html.lisp
(gcode strike-face html-language ("<del>~a</del>") (contents))
#+END_SRC
***** test
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/tests.lisp
(let* ((l4 (strike "striked text")))
  (generate-code l4 html t))
#+END_SRC
**** underline-face
***** code
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-html.lisp
(gcode underline-face html-language ("<ins>~a</ins>") (contents))
#+END_SRC
***** test
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/tests.lisp
(let* ((l5 (underline "underlined text")))
  (generate-code l5 html t))
#+END_SRC
**** newline
***** code
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-html.lisp
(gcode newline html-language ("<br>") ())
#+END_SRC
***** test
#+BEGIN_SRC lisp +n -r :results output :exports none :tangle src/tests.lisp
(let* ((l1 (newline)))
  (generate-code l1 html t))
#+END_SRC

#+RESULTS:
: <br>

**** item
***** code
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-html.lisp
(gcode item html-language ("<li>~a</li>") (contents))
#+END_SRC
***** test
#+BEGIN_SRC lisp +n -r :results output :exports none :tangle src/tests.lisp
(let* ((l1 (item "Hello itemized world"))
       (l2 (item "Hello " (b "itemized") " world")))
  (generate-code l1 html t)
  (terpri)
  (generate-code l2 html t))
#+END_SRC

#+RESULTS:
: <li>Hello itemized world</li>
**** ordered-list
***** code
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-html.lisp
(defmethod generate-code ((node ordered-list)
                          (lang html-language)
                          stream)
  (format stream "<ol>~%")
  (loop for item in (contents node)
        do (format stream "  ~a~%" (gcodenil-exp item)))
  (format stream "</ol>~%"))
#+END_SRC
***** test
#+BEGIN_SRC lisp +n -r :results output :exports none :tangle src/tests.lisp
(let* ((l1 (enumerate (item "Element 1")
                      (item "Element 2"))))
  (generate-code l1 html t))
#+END_SRC

#+RESULTS:
: <li>Hello itemized world</li>
**** unordered-list
***** code
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-html.lisp
(defmethod generate-code ((node unordered-list)
                          (lang html-language)
                          stream)
  (format stream "<ul>~%")
  (loop for item in (contents node)
        do (format stream "  ~a~%" (gcodenil-exp item)))
  (format stream "</ul>~%"))
#+END_SRC
***** test
#+BEGIN_SRC lisp +n -r :results output :exports none :tangle src/tests.lisp
(let* ((list2 (itemize (item "Element 1")
                      (item "Element 2"))))
  (generate-code list2 html t))
#+END_SRC

#+RESULTS:
: <ul>
:   <li>Element 1</li>
:   <li>Element 2</li>
: </ul>

**** link
***** code
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-html.lisp
(gcode link html-language ("<a href='~a.html'>~a</a>") (target contents))
#+END_SRC
***** test
#+BEGIN_SRC lisp +n -r :results output :exports none :tangle src/tests.lisp
(let* ((l1 (link final "listo para terminar")))
  (generate-code l1 html t))
#+END_SRC

#+RESULTS:
: <a href='FINAL'>listo para terminar</a>
**** action
***** code
#+begin_src lisp :results none :export code :tangle src/writer-html.lisp
(gcode action html-language ("<div class='~a' style='cursor: pointer;' onclick=\"this.innerHTML=\'~a\'\">~a</div>") (action-id contents trigger-text))
#+end_src
**** image
#+begin_src lisp :results none :export code :tangle src/writer-html.lisp
  (defmethod generate-code ((node image) (lang html-language) stream)
   (let* ((align-style (case (align node)
			 (:center "display: block; margin-left: auto; margin-right: auto;")
			 (:left "float: left;")
			 (:right "float: right;")
			 (t "")))
	  (size-style (if (size node)
			(format nil "width: ~a%; " (size node))
			"")))  ; Empty string when no size
     (format stream "<img src=\"~a\" alt=\"~a\" style=\"~a ~a\">"
	     (src node)
	     (alt-text node)
	     align-style
	     size-style)))
#+end_src
**** sound
#+begin_src lisp :results none :export code :tangle src/writer-html.lisp
(defmethod generate-code ((node start-sound) (lang html-language) stream)
  (format stream "<audio controls~a>~%  <source src=\"~a\" type=\"audio/mpeg\">~%  ~a~%</audio>"
          (if (alt-text node) (format nil " title=\"~a\"" (alt-text node)) "")
          (src node)
          (if (alt-text node) 
              (format nil "Your browser does not support the audio element (~a)." (alt-text node))
              "Your browser does not support the audio element.")))
#+end_src
**** video
#+begin_src lisp :results none :export code :tangle src/writer-html.lisp
(defmethod generate-code ((node video) (lang html-language) stream)
  (format stream "<video controls~a>~%  <source src=\"~a\" type=\"video/mp4\">~%  ~a~%</video>"
          (if (alt-text node) (format nil " title=\"~a\"" (alt-text node)) "")
          (src node)
          (if (alt-text node) 
              (format nil "Your browser does not support the video element (~a)." (alt-text node))
              "Your browser does not support the video element.")))
#+end_src
**** change-bg-color
#+begin_src lisp :results none :export code :tangle src/writer-html.lisp
(defmethod generate-code ((node change-bg-color) (lang html-language) stream)
  (format stream "<div style=\"position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: ~a; z-index: -1;\"></div>"
          (color node)))
#+end_src

**** change-bg-image
#+begin_src lisp :results none :export code :tangle src/writer-html.lisp
(defmethod generate-code ((node change-bg-image) (lang html-language) stream)
  (format stream "<div style=\"~
                 position: fixed; ~
                 top: 0; ~
                 left: 0; ~
                 width: 100%; ~
                 height: 100%; ~
                 z-index: -1; ~
                 background-image: url('~a'); ~
                 background-repeat: no-repeat; ~
                 background-position: center; ~
                 background-size: cover; ~
                 background-attachment: fixed;\"></div>"
          (image-url node)))
#+end_src
**** font
#+begin_src lisp :results none :export code :tangle src/writer-html.lisp
  (defmethod generate-code ((node font) (lang html-language) stream)
    (format stream "<p style=\"font-family: ~a;\">"
	    (new-font node))
 (loop for item in (contents node)
        do (format stream "~a~%" (gcodenil-exp item)))
  (format stream "</p>~%"))
#+end_src
**** whiteboard
#+begin_src lisp :results none :export code :tangle src/writer-html.lisp
(defmethod generate-code ((node whiteboard) (lang html-language) stream)
  (format stream "<section class=\"whiteboard-section\">~%")
  (format stream "  <div class=\"whiteboard-wrap\">~%")
  (format stream "    <div class=\"whiteboard-container\">~%")
  (format stream "      <div class=\"whiteboard-header\"></div>~%")
  (format stream "      <div class=\"whiteboard-content\">~%")
  (format stream "        <div class=\"content-title\">~%~a~%</div>~%" (wb-title node))
  (format stream "        <div class=\"content-body\">~%")
  
  ;; Generate content
  (loop for content in (contents node)
        do (format stream "          ~a~%" (gcodenil-exp content)))
  
  ;; Add author if specified
  (when (author node)
    (format stream "          <p class=\"quote-author\">~a</p>~%" (author node)))
  
  (format stream "        </div>~%")
  (format stream "        <div class=\"whiteboard-spacer\"></div>~%")
  (format stream "      </div>~%")
  (format stream "      <div class=\"whiteboard-footer\"></div>~%")
  (format stream "    </div>~%")
  (format stream "  </div>~%")
  (format stream "</section>~%"))
#+end_src

**** math-inline
#+begin_src lisp :results none :export code :tangle src/writer-html.lisp
(gcode math-inline html-language ("$~a$") (math))
#+end_src
**** math-center
#+begin_src lisp :results none :export code :tangle src/writer-html.lisp
(defmethod generate-code ((node math-center) (lang html-language) stream)
  (format stream "<div style=\"text-align: center; margin: 1em 0;\">")
  (format stream "\\[~a\\]" 
          (math node))
  (format stream "</div>"))
#+end_src
**** code-node
#+begin_src lisp :results none :export code :tangle src/writer-html.lisp
(defmethod generate-code ((node code-node) (lang html-language) stream)
  (format stream "<pre><code class=\"language-~a\">~a</code></pre>~%"
          (string-downcase (language node))
          
           (format nil "~a~%"(code node)))
  
  ;; Add highlight.js initialization if not already added
  (format stream "<script>
  if (!window.hljsInitialized) {
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css';
    document.head.appendChild(link);
    
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js';
    script.onload = () => { 
      hljs.highlightAll();
      window.hljsInitialized = true;
    };
    document.head.appendChild(script);
  }
  </script>"))
#+end_src
**** scene
***** description
Ojo, aqu√≠ vamos a asumir que cada escena es una p√°gina web, que se llama (id).html.

Eso significa que VAMOS A ASUMIR que en este caso stream es el nombre de un directorio.

***** code
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-html.lisp
 (defmethod generate-code ((node scene)
			  (lang html-language)
			  stream)

 ;; lo primero es crear el fichero correspondiente
   (let* ((filename (concatenate 'string stream (symbol-name (id node)) ".html")))
	(with-open-file (f filename
			 :direction :output
			 :if-exists :supersede)
		(format f "<html>~%
		<header>~%
	          <link rel=\"stylesheet\" href=\"wb-styles.css\">~%
	            <script>MathJax = {tex: {inlineMath: [['$', '$']]}};~%
	            </script>~%
                    <script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\">~%
                    </script>  ~%
                 </header>~%
              <body>~%")
	(loop for item in (contents node) doing
		  (format f "  ~a~%" (gcodenil-exp item)))
	          (format f " </body>~%</html>"))))
#+END_SRC
***** test
#+BEGIN_SRC lisp +n -r :results output :exports none :tangle src/tests.lisp
(let* ((l1 (scene ejemplo
                  "Texto de ejemplo" (newline)
                  (link final "Vamos para el final") (newline)
                  "NOT THE END"))
       (l2 (scene final
                  "Este es el final" (newline)
                  (link ejemplo "O puedes regresar al princpio") (newline)
                  "THE END")))
  (generate-code l1 html "/tmp/")
  (generate-code l2 html "/tmp/"))
#+END_SRC

#+RESULTS:

**** story
***** code
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-html.lisp
  (defmethod generate-code ((node story) (lang html-language) stream)
  "Generates HTML files for all scenes in the story including whiteboard CSS."
  ;; First create the output directory if it doesn't exist
  (ensure-directories-exist stream)
  
  ;; Generate wb-styles.css file
  (with-open-file (css (merge-pathnames "wb-styles.css" stream)
                      :direction :output
                      :if-exists :supersede)
    (format css "@import url('https://fonts.googleapis.com/css2?family=Gochi+Hand&display=swap');

.whiteboard-section {
background-image: url(\"bg-wall.jpg\");
background-repeat: no-repeat;
background-size: cover;
background-position: bottom center;
padding: 2em 4em 6.9em 4em; 
}

.whiteboard-wrap {
margin: 0 auto;
max-width: 940px;
padding: 20px;
border-radius: 20px;
background-color: rgba(255,255,255,0.60);
box-shadow: rgba(50, 50, 93, 0.25) 0px 6px 12px -2px, rgba(0, 0, 0, 0.3) 0px 3px 7px -3px;
}

.whiteboard-container {
position: relative;
border-radius: 5px;
border: 14px solid #c8c9ca;
box-shadow: 0 0 0 1px #ffffff, 0 0 0 14px #babcbd, inset -1px 2px 2px #edeff0, 0px 5px 15px rgba(0, 0, 0, 0.35);
overflow: hidden;
background: #FFFFFF;
background: radial-gradient(at left top, #FFFFFF, #FDFCFC);
}

.whiteboard-header {
height: 50px;
background-image: url(\"magnet-buttons.png\");
background-repeat: no-repeat;
background-position: bottom right;
margin-right: 10px;
}

.whiteboard-footer {
position: absolute;
width: 100%;
bottom: 0px;
height: 36px;
background-image: url(\"marker-and-eraser.png\");
background-repeat: no-repeat;
background-position: center;
background-size: 300px 36px;
}

.whiteboard-content {
padding: 1em 2em;
font-family: 'Gochi Hand', cursive;
font-size: 1.4vw;
line-height: 1.5vw;
color: #3a4ba1; 
}

.content-title {
border-bottom: 1px dashed #CCCCCC;
padding-bottom: 2px;
margin-bottom: 1em;
}

.quote-author {
text-align: right;
}

@media only screen and (max-width: 798px) {
.whiteboard-content {
font-size: 16px !important;
line-height: 16px;
}
}"))

  ;; Generate an index.html file that links to all scenes
  (with-open-file (index (merge-pathnames "index.html" stream)
                      :direction :output
                      :if-exists :supersede)
    (format index "<html>~%<head>~%<title>~a</title>~%<link rel=\"stylesheet\" href=\"wb-styles.css\">~%</head>~%<body>" (story-title node))
    (format index "<h1>~a</h1>" (story-title node))
    (format index "<p>By ~a</p><ul>" (author node))
    
    ;; Create links to all scenes
    (loop for scene in (contents node)
          when (typep scene 'scene)
          do (format index "<li><a href='~a.html'>~a</a></li>" 
                     (symbol-name (id scene)) 
                     (symbol-name (id scene))))
    
    (format index "</ul></body></html>"))
  
  ;; Generate HTML files for each scene
  (loop for element in (contents node)
        when (typep element 'scene)
        do (generate-code element html stream)))
#+END_SRC

** language undum

*** description
    In this section I'll add the code-generation routines for undum.  The src blocks will be tangled to writer-undum.lisp.

*** add the package to the file
    #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-undum.lisp
    (in-package :clif)
    #+END_SRC

*** define the undum class
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-undum.lisp
     (defnode undum-language ()
       ()
       :documentation "A class to represent the undum system.")
     #+END_SRC
**** constant
     #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-undum.lisp
     (defparameter undum (undum-language))
     #+END_SRC
**** no test because there is nothing to test :-(
**** initialization for the system
***** description
An undum "game" is made of two elements: a .js file with the situations and an html file, that is used to visualize the logic in the js.

This function genarates the html file needed for the game.  In a first iteration we are going to just duplicate the file that comes with undum.

Maybe in a future, I'll add a configuration file, where we can change some of these things.

There are some things that we changed from the original undum.

The first one is that now, the files undum.js, undum.css and jquery.js, and game.js should be in the same directory as the html file.

In the undum.css there are some images that are stored in a folder named img, that should also be on the same directory as everything else.

Maybe later, we can think of a better design for that, but so far, this are the facts.

Actually, I'm going to add those files to a folder assets in the git repository.

In fact, an actual initialize-system function should create the html AND copy all those elements to wherever the story si going to be held.  But, those are problems for the future.

***** code
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (defmethod initialize-undum (obj (lang undum-language) stream)
        "This is taken verbatim from a slightly modified version of the html that comes with the undum tutorial."

        ;; first the declaration of the doctype
        (format stream "<!DOCTYPE HTML>~%")

        ;; here we start the  html tag
        (format stream "<html lang=\"en\">")

        ;; let's write the head
        (format stream "
        <head>
          <meta charset=\"utf-8\">
          <!-- Game Title: edit this -->
          <title>Undum with Common Lisp</title>
          <!-- End of Game Title -->

          <!-- This is your game's stylesheet, modify it if you like. -->
          <link media=\"screen\"
                rel=\"stylesheet\" href=\"undum.css\">

          <!-- Suppport for mobile devices. -->
          <meta name=\"viewport\" content=\"user-scalable=no, width=device-width\">
          <link rel=\"apple-touch-icon\" href=\"media/img/iphone/icon.png\">
          <link rel=\"apple-touch-startup-image\" href=\"media/img/iphone/splash.png\">
          <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">
          <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\">
          <!--[if !IE]>-->
          <link media=\"only screen and (max-width: 640px)\"
                rel=\"stylesheet\" type=\"text/css\" href=\"media/css/undum-mobile.css\">
          <!--<![endif]-->

        </head>
      ")

        ;; let's open the body tag
        (format stream "
        <body>
      ")

        ;; the toolbar for the mobile devices
        ;; it contains a short description of the title
        (format stream "
          <!-- This isn't needed and isn't visible in desktop versions,
               because we can display the character information and the
               tools onscreen all the time. -->
          <div id=\"toolbar\">
            <!-- Set this to be a small version of the title, for the
                 toolbar on mobile devices. -->
            <h1>Learning Undum</h1>
            <div class=\"nav\">
              <a href=\"#\" class=\"button\" id=\"menu-button\">Menu</a>
            </div>
          </div>
      ")

        ;; let's open the div page
        (format stream "
          <div id=\"page\">
      ")

        ;; now the text that appears on the left
        (format stream "
            <div id=\"tools_wrapper\">
      ")

        ;; the following information is dependent on the story
        ;; and maybe in a future, we'll need to modify it
        ;; in the original html said: Game background edit this
        ;; this may be the info_panel
        (format stream "
              <div id=\"info_panel\" class=\"tools left\">
                <!-- Game Background: edit this -->
                <h1>Undum</h1>
                <p>
                  ESTE EL C√ìDIGO QUE APARECE A LA IZQUIERDA
                </p>
                <!-- End of Game Background -->

                <div class='buttons'>
                  <button id=\"save\">Save</button><button id=\"erase\">Erase</button>
                </div>
              </div>
      ")

        ;; now comes the character panel
        (format stream "
              <div id=\"character_panel\" class=\"tools right\">
                <h1>Cosas del personaje</h1>
                <div id=\"character\">
                  <div id=\"character_text\">
                    <div id=\"character_text_content\"></div>
                  </div>
                  <div id=\"qualities\"></div>
                </div>
              </div>
      ")

        ;; let's cdloe the div.tools_wrapper
        (format stream "      </div> <!-- End of div.tools_wrapper -->
      ")

        ;; now, the mid_panel
        ;; there is some info related to the game
        ;; in this portion of the html
        (format stream "
            <div id=\"mid_panel\">
              <div id=\"title\">
                <div class=\"label\">

                  <!-- Game Title: edit this -->
                  <h1>Mi primera historia con undum <span>&amp;</span><br>
                    Interactive Example</h1>
                  <h2>por @fernan2rodriguez</h2>
                  <!-- End of Game Title -->

                  <noscript><p class=\"noscript_message\">This game requires 
                    Javascript.</p></noscript>
                  <p class=\"click_message\">click to begin</p>
                </div>
              </div>
      ")

        ;; the content wrapper
        (format stream "
              <div id=\"content_wrapper\">
                <div id=\"content\">
                </div>
                <a name=\"end_of_content\"></a>
              </div>
      ")

        ;; the legal part
        (format stream "
              <div id=\"legal\">
                <!-- Your Copyright: edit this -->
                <p>Estas son las cosas de copyright.</p>
                <!-- End of Your Copyright -->

                <!-- This line is totally optional. -->
                <p>Created with <a href=\"http://idmillington.github.io/undum/\">Undum</a>.</p>
              </div>")

        ;; let's close the div for the midpanel
        (format stream "
            </div>")

        ;; let's close the div page
        (format stream "
          </div> <!-- End of div.page -->
      ")


        ;; now, let's add the UI elements
        (format stream "
          <!-- Holds UI elements that will be cloned and placed in the main
               page. This block itself is always hidden. -->
          <div id=\"ui_library\">
            <div id=\"quality\" class=\"quality\">
              <span class=\"name\" data-attr=\"name\"></span>
              <span class=\"value\" data-attr=\"value\"></span>
            </div>

            <div id=\"quality_group\" class=\"quality_group\">
              <h2 data-attr=\"title\"></h2>
              <div class=\"qualities_in_group\">
              </div>
            </div>

            <div id=\"progress_bar\" class=\"progress_bar\">
              <span class=\"name\" data-attr=\"name\"></span>
              <span class=\"value\" data-attr=\"value\"></span>
              <div class=\"progress_bar_track\">
                <div class=\"progress_bar_color\" data-attr=\"width\">
                </div>
              </div>
              <span class=\"left_label\" data-attr=\"left_label\"></span>
              <span class=\"right_label\" data-attr=\"right_label\"></span>
            </div>

            <hr id=\"turn_separator\">
          </div>
      ")

        ;; let's load the libraries jquery.js and undum.js
        ;; right now the libraries are in the same directory
        ;; as the original story
        (format stream "
          <!-- Load the libraries we depend on -->
          <script type=\"text/javascript\" src=\"jquery-2.1.3.min.js\"></script>
          <script type=\"text/javascript\" src=\"undum.js\"></script>
      ")

        ;; now the name of the file with our game
        ;; right now the game is supposed to be in the same
        ;; folder as the html and the name should be undum-game.js
        (format stream "
          <!-- Change the name of this file. It is your main game file. -->
          <script type=\"text/javascript\"
                  src=\"undum-game.js\">
          </script>")

        ;; let's close the body tag
        (format stream "
        </body>
      ")


        ;; and finally, we close the html tag
        (format stream "</html>")

        )
      #+end_src

***** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ()

        (bformat t "testing initialize-undum. check /tmp/clif.html")
        (with-open-file (f "/tmp/clif.html" :direction :output
                           :if-exists :supersede)
          (initialize-undum t undum f)))
      #+end_src

      #+RESULTS:
      : ================================================
      :  testing initialize-undum. check /tmp/clif.html
      : ================================================
      : 
      
*** code generation for undum
**** generation of basic elements (maybe this should be in gagm?)
***** description
In this section we define the code generation for the basic elements as numbers, strings and symbols
***** number
****** code
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (defmethod generate-code ((obj number) (lang undum-language) stream)
        (format stream "~a" obj))
      #+end_src
****** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (generate-code 4 undum t)
      #+end_src
***** string
****** code
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (defmethod generate-code ((obj string) (lang undum-language) stream)
        (format stream "~a" obj))
      #+end_src
****** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (generate-code "hello world!" undum t)
      #+end_src

***** symbol
****** code
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (defmethod generate-code ((obj symbol) (lang undum-language) stream)
        (format stream "~a" (symbol-name obj)))
      #+end_src
****** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (generate-code 'hello-world undum t)
      #+end_src
***** list
****** code
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (defmethod generate-code((node list)
                               (lang undum-language)
                               stream)
        (format stream "~{~a~}"
                (mapcar (lambda (x) (gcodenil-exp x))
                        node)))
      #+end_src
****** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (generate-code (list 'hello-world 1 "two") undum t)
      (generate-code nil undum t)
      #+end_src
***** nil
****** description
When we receive a nil, don't write anything
****** code
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (defmethod generate-code((node (eql nil))
                               (lang undum-language)
                               stream)
        (format stream ""))
      #+end_src
****** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (generate-code nil undum t)
      #+end_src

**** basic-situation
***** description
In this section we define how to generate code for a basic-situation.
***** code
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (defmethod generate-code ((obj basic-situation) (lang undum-language) stream)
        (format stream
      "    ~a: new undum.SimpleSituation(
               \"~{~a~}\"
          )"
      (id obj)
      (mapcar (lambda (x) (generate-code x lang nil)) (contents obj))))
      #+end_src
***** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ((bs1 (basic-situation 'test1
                                   "hello world,"
                                   " my first situation"
                                   ", with 3 lines"))
             (bs2 (basic-situation 'test2
                                   "<h1>Un juego con una sola situaci√≥n</h1>"
                                   "<p>Esta es una √∫nica situaci√≥n, con texto.</p>."
                                   "<p>Presiona <a href='ultimo'>aqu√≠ para terminar...</a></p>")))
        (bformat t "testing generate-code for basic situation")
        (generate-code bs1 undum t)
        (terpri) (terpri)
        (generate-code bs2 undum t))
      #+end_src

      #+RESULTS:
      : <a href='START'>al comienzo otra vez...</a>

**** link
***** description
In this section we define how to generate code for a link.
***** +code v1 (with gcode: no css-classes)+
      #+begin_src lisp :results none 
      (gcode link undum-language ("<a href='~a'>~a</a>") (target contents))
      #+end_src
***** code v2 (with macro generate-code-for-html-tag)
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (generate-code-for-html-tag link
         (format stream "<a class='~a' href='~a'>~a</a>"
                 css-classes
                 (gcodenil target)
                 contents))
      #+end_src
***** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ((l1 (link "test1" "click here to go to 'test1"))
                (l2 (link "test2" :transient "click here to go to 'test2"))
                (l3 (link "test3" :transient "click here to go" " to 'test2" " with list"))
                (l4 (link "test4" :transient "click here to go" :another_class " to 'test2" " with list")))
        (bformat t "testing the code-generation for link")
        (generate-code l1 undum t) (terpri)
        (generate-code l2 undum t) (terpri)
        (generate-code l3 undum t) (terpri)
        (generate-code l4 undum t) (terpri))
      #+end_src

      #+RESULTS:
      : <a href='START'>al comienzo otra vez...</a>

**** newline-in-js-class
***** description
In this section we define how to generate code for a newline-in-js
***** code
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (defmethod generate-code ((obj newline-in-js-class) (lang undum-language) stream)
        (format stream "\\~%"))
      #+end_src
***** test
****** simple test1
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (generate-code (nline) undum t)
      #+end_src
****** test within a situation
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ((bs1 (basic-situation "start"
                                   "<h1>Un juego con una sola situaci√≥n</h1>"
                                   (nline)
                                   "<p>Esta es una √∫nica situaci√≥n, con texto.</p>"
                                   (nline)
                                   "<p>Presiona " (link 'ultimo "aqu√≠ para terminar.") "</p>"))
             (bs2 (basic-situation "ultimo"
                                   "<p class='transient'>Felicitaciones</p>"
                                   (nline)
                                   "<p>Has terminado tu primera aventura</p>"
                                   (nline)
                                   "<p>FIN</p>")))
        (bformat t "testing generate-code for story")
        (generate-code bs1 undum t)
        (terpri) (terpri)
        (generate-code bs2 undum t))
      #+end_src

**** story
***** description
In this section we define how to generate code for a story.  This means to create the whole .js file.
***** code
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (defmethod generate-code ((obj story-class) (lang undum-language) stream)
        "This is taken verbatim from the .js file that comes with the example in undum."

        ;; first the initial comment
        (format stream "// ---------------------------------------------------------------------------
      // Edit this file to define your game. It should have at least four
      // sets of content: undum.game.situations, undum.game.start,
      // undum.game.qualities, and undum.game.init.
      // ---------------------------------------------------------------------------
      ")

        ;; now the game id
        (format stream "
      /* A unique id for your game. This is never displayed. I use a UUID,
       ,* but you can use anything that is guaranteed unique (a URL you own,
       ,* or a variation on your email address, for example). */
      undum.game.id = \"be1c95b9-cbc7-48c6-8e6a-89837aa9113e\";
      ")

        ;; the version of the game
        (format stream "
      /* A string indicating what version of the game this is. Versions are
       ,* used to control saved-games. If you change the content of a game,
       ,* the saved games are unlikely to work. Changing this version number
       ,* prevents Undum from trying to load the saved-game and crashing. */
      undum.game.version = \"1.0\";
      ")

        ;; the variables that control the visualization (so far they are hardcoded)

        (format stream "
      /* A variable that changes the fade out speed of the option text on
       ,* a mobile. */
      undum.game.mobileHide = 2000

      /* A variable that changes the options fade out speed. */
      undum.game.fadeSpeed = 1500

      /* A variable that changes the slide up speed after clicking on an
       ,* option. */
      undum.game.slideUpSpeed = 500
      ")

        ;; now come the situations
        ;; first, we add the comment
        (format stream "
      /* The situations that the game can be in. Each has a unique ID. */
      ")

        (format stream "undum.game.situations = {~%")

        ;; let's add the situations from the slot in the class
        ;; first, we add the first situation
        (generate-code (first (situations obj)) lang stream)

        ;; now we add the rest of the situations
        ;; separated by a comma

        (loop for situation in (rest (situations obj)) doing
              ;; first, let's add the comma
              ;; and two new lines
              (format stream ",~2%")
              ;; now let's add the next situation
              (generate-code situation lang stream)
              )

        ;; let's close the situations brackets
        ;; and add a semicolon
        (format stream "~%};~%")

        ;; let's add the id of the starting situation
        (format stream "
      // ---------------------------------------------------------------------------
      /* The Id of the starting situation. */
      undum.game.start = \"~a\";
      " (initial-situation obj))

        ;; this is the place to define the qualities
        ;; first the comment

        (format stream "
      // ---------------------------------------------------------------------------
      /* Here we define all the qualities that our characters could
       ,* possess. We don't have to be exhaustive, but if we miss one out then
       ,* that quality will never show up in the character bar in the UI. */
      ")

        ;; and now we define the qualities
        (format stream "
      undum.game.qualities = {
          skill: new undum.IntegerQuality(
              \"Skill\", {priority:\"0001\", group:'stats'}
          ),
          stamina: new undum.NumericQuality(
              \"Stamina\", {priority:\"0002\", group:'stats'}
          ),
          luck: new undum.FudgeAdjectivesQuality( // Fudge as in the FUDGE RPG
              \"<span title='Skill, Stamina and Luck are reverently borrowed from the Fighting Fantasy series of gamebooks. The words representing Luck are from the FUDGE RPG. This tooltip is illustrating that you can use any HTML in the label for a quality (in this case a span containing a title attribute).'>Luck</span>\",
              {priority:\"0003\", group:'stats'}
          ),

          inspiration: new undum.NonZeroIntegerQuality(
              \"Inspiration\", {priority:\"0001\", group:'progress'}
          ),
          novice: new undum.OnOffQuality(
              \"Novice\", {priority:\"0002\", group:'progress', onDisplay:\"&#10003;\"}
          )
      };
      ")

        ;; the groups of the qualities
        (format stream "
      // ---------------------------------------------------------------------------
      /* The qualities are displayed in groups in the character bar. This
       ,* determines the groups, their heading (which can be null for no
       ,* heading) and ordering. QualityDefinitions without a group appear at
       ,* the end. It is an error to have a quality definition belong to a
       ,* non-existent group. */
      undum.game.qualityGroups = {
          stats: new undum.QualityGroup(null, {priority:\"0001\"}),
          progress: new undum.QualityGroup('Progress', {priority:\"0002\"})
      };
      ")

        ;; the function that is run at the begining of the game
        (format stream "
      // ---------------------------------------------------------------------------
      /* This function gets run before the game begins. It is normally used
       ,* to configure the character at the start of play. */
      undum.game.init = function(character, system) {
          character.qualities.skill = 12;
          character.qualities.stamina = 12;
          character.qualities.luck = 0;
          character.qualities.novice = 1;
          character.qualities.inspiration = 0;
          system.setCharacterText(\"<p>You are starting on an exciting journey.</p>\");
      };")
  
        )
      #+end_src
***** test
****** test within a story
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ((bs1 (basic-situation "startup"
                                   "<h1>Un juego con una sola situaci√≥n</h1>"
                                   (nline)
                                   "<p>Esta es una √∫nica situaci√≥n, con texto.</p>"
                                   (nline)
                                   "<p>Presiona " (link 'ultimo "aqu√≠ para terminar.") "</p>"))
             (bs2 (basic-situation "ultimo"
                                   "<p class='transient'>Felicitaciones</p>"
                                   (nline)
                                   "<p>Has terminado tu primera aventura</p>"
                                   (nline)
                                   "<p>FIN</p>"))
             (story1 (story (list bs1 bs2) "startup")))

        (bformat t "testing generate-code for story")
        (generate-code story1 undum t))
      #+end_src

****** test within a story to a file
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ((bs1 (basic-situation "start"
                                   "<h1>Un juego con una sola situaci√≥n</h1>"
                                   (nline)
                                   "<p>Esta es una √∫nica situaci√≥n, con texto.</p>"
                                   (nline)
                                   "<p>Presiona " (link "ultimo" "aqu√≠ para terminar.") "</p>"))
             (bs2 (basic-situation "ultimo"
                                   "<p class='transient'>Felicitaciones</p>"
                                   (nline)
                                   "<p>Has terminado tu primera aventura</p>"
                                   (nline)
                                   "<p>FIN</p>"))
             (story1 (story (list bs1 bs2) "start")))

        (bformat t "testing generate-code to a file for a story")
        (with-open-file (f "/tmp/undum-game.js" :direction :output
                           :if-exists :supersede)
            (generate-code story1 undum f)))
      #+end_src

      #+RESULTS:
      : =============================================
      :  testing generate-code to a file for a story
      : =============================================
      : 

**** html-h1
***** description
In this section we define how to generate code for a h1 tag.
***** +code v1 (with gcode)+
      #+begin_src lisp :results none 
      (gcode html-h1 undum-language ("<h1 class='~a'>~a</h1>") (css-classes contents))
      #+end_src
***** +code v2 (with a generate-code method)+
      #+begin_src lisp :results none 
      (defmethod generate-code ((node html-h1) (lang undum-language) stream)
        (format stream "<h1 class='~a'>~a</h1>"
                (if (css-classes node)
                    (with-output-to-string (s)
                      (format s "~{~a~^ ~}"
                              (css-classes node)))
                    ;; else
                    "")
                (gcodenil contents)))

      #+end_src
***** code v3 (with the macro generate-code-for-simple-html-tag)
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (generate-code-for-simple-html-tag html-h1 "h1")

      #+end_src
***** test v1
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ((l1 (h1 "This is a test for a header"))
             (l2 (h1 "This is a test" " for a header" " with list as contents"))
             (l3 (h1 :transient "This is a test"))
             (l4 (h1 :transient "This is a test" :with_2_classes " with css-classes")))
        (bformat t "testing the constructor for h1")
        (generate-code l1 undum t)
        (terpri)
        (generate-code l2 undum t)
        (terpri)
        (generate-code l3 undum t)
        (terpri)
        (generate-code l4 undum t))
      #+end_src

      #+RESULTS:
      : <h1>This is a test for a header</h1>

**** html-p
***** description
In this section we define how to generate code for a p
***** +code v1 (with gcode)+
      #+begin_src lisp :results none
      (gcode html-p undum-language ("<p>~a</p>") (contents))
      #+end_src
***** code v2 (with macro generate-code-for-simple-html-tag)
      #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
      (generate-code-for-simple-html-tag html-p "p")
      #+end_src
***** test
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ((l1 (p "This is a test for a paragraph"))
             (l2 (p "This is a test" " for a paragraph" " with list as contents"))
             (l3 (p :transient "This is a test"))
             (l4 (p :transient "This is a test" :with_2_classes " with css-classes")))
        (bformat t "testing the code generation for <p>")
        (generate-code l1 undum t)
        (terpri)
        (generate-code l2 undum t)
        (terpri)
        (generate-code l3 undum t)
        (terpri)
        (generate-code l4 undum t))
      #+end_src

      #+RESULTS:
      : <h1>This is a test for a header</h1>
      
**** html-br
***** description
In this section we define how to generate code for a br tag. 
***** code
 #+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
   (defmethod generate-code ((obj html-br) (lang undum-language) stream)
    (format stream "<br>"))
#+end_src
***** test
  #+begin_src lisp :results output :export code :tangle src/tests.lisp
    (let* ((test-paragraph (p "First line" (br) "Second line")))
      (bformat t "Testing br tag")
      (generate-code test-paragraph undum t))
#+end_src
**** html-ul
***** description
In this section we define how to generate code for an ul
***** code
#+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
  (generate-code-for-simple-html-tag html-ul "ul")
#+end_src
***** tests
-- tests in li
**** html-ol
***** description
In this section we define how to generate code for an ol
***** code
#+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
  (generate-code-for-simple-html-tag html-ol "ol")
#+end_src
***** tests
-- tests in li
**** html-li
***** description
In this section we define how to generate code for a li
***** code
#+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
(generate-code-for-simple-html-tag html-li "li")
#+end_src
***** tests
#+begin_src lisp :results output :export code :tangle src/tests.lisp
(let* (;; Test basic list items
       (simple-item (li "Simple list item"))
       (styled-item (li :highlight "Styled list item"))
       (multi-content (li "First part" " second part"))
       (nested-item (li (p "Paragraph inside list item")))
       
       ;; Test unordered lists
       (simple-list (ul (li "Item 1") (li "Item 2")))
       (styled-list (ul :menu (li "Home") (li "About") (li "Contact")))
       (nested-list (ul (li "Top level" (ul (li "Nested 1") (li "Nested 2"))))))

  (bformat t "Testing individual list items")
  (generate-code simple-item undum t) (terpri)
  (generate-code styled-item undum t) (terpri)
  (generate-code multi-content undum t) (terpri)
  (generate-code nested-item undum t) (terpri)
  
  (bformat t "~%Testing unordered lists")
  (generate-code simple-list undum t) (terpri)
  (generate-code styled-list undum t) (terpri)
  (generate-code nested-list undum t) (terpri)
  )
#+end_src

**** html-button
***** description
In this section we define how to generate code for an html button
***** code
#+begin_src lisp :results none :export code :tangle src/writer-undum.lisp
  (generate-code-for-html-tag html-button
    (format stream "<button class='~a' onclick='this.disabled=true; ~(~a~)()'>~a</button>"
	    css-classes
	    (gcodenil function-name)
	    contents))
#+end_src
***** tests

** language LaTeX
*** description
En este /formato de salida/ cada escena es una p√°gina y cada historia es un documento
*** declaracion de la clase
 #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-latex.lisp
     (defnode latex-language ()
       ()
       :documentation "A class to represent the latex language.")
     #+END_SRC
**** constant
#+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-latex.lisp
(defparameter latex (make-instance 'latex-language))
#+END_SRC
*** generation of basic elements
In this section we define the code generation for the basic elements as numbers, strings and symbols
**** number
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(defmethod generate-code ((obj number) (lang latex-language) stream)
  (format stream "~a" obj))
#+end_src
**** string
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(defmethod generate-code ((obj string) (lang latex-language) stream)
  (format stream "~a" obj))
#+end_src
**** symbol
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(defmethod generate-code ((obj symbol) (lang latex-language) stream)
  (format stream "~a" (symbol-name obj)))
#+end_src
**** list
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(defmethod generate-code ((node list) (lang latex-language) stream)
  (format stream "~{~a~}" (mapcar (lambda (x) (gcodenil-exp x)) node)))
#+end_src
**** nil
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(defmethod generate-code ((node (eql nil)) (lang latex-language) stream)
  (format stream ""))
#+end_src
*** generaci√≥n para cada nodo
**** text
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(gcode text latex-language ("~a~%") (contents))
#+end_src
**** title
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(gcode title latex-language ("\\section*{~a}~%") (contents))
#+end_src
**** subtitle
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(gcode subtitle latex-language ("\\subsection*{~a}~%") (contents))
#+end_src
**** bold-face
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(gcode bold-face latex-language ("\\textbf{~a}") (contents))
#+end_src
**** italic-face
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(gcode italic-face latex-language ("\\textit{~a}") (contents))
#+end_src
**** tt-face
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(gcode tt-face latex-language ("\\texttt{~a}") (contents))
#+end_src
**** strike-face
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(gcode strike-face latex-language ("\\sout{~a}") (contents))
#+end_src
**** underline-face
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(gcode underline-face latex-language ("\\underline{~a}") (contents))
#+end_src

**** newline
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
  (gcode newline latex-language ("~%\\vspace{\\baselineskip}~%") ())
#+end_src
**** item
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(gcode item latex-language ("\\item ~a") (contents))
#+end_src
**** ordered-list
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(defmethod generate-code ((node ordered-list) (lang latex-language) stream)
  (format stream "\\begin{enumerate}~%")
  (loop for item in (contents node)
        do (format stream "  ~a~%" (gcodenil-exp item)))
  (format stream "\\end{enumerate}~%"))
#+end_src
**** unordered-list
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(defmethod generate-code ((node unordered-list) (lang latex-language) stream)
  (format stream "\\begin{itemize}~%")
  (loop for item in (contents node)
        do (format stream "  ~a~%" (gcodenil-exp item)))
  (format stream "\\end{itemize}~%"))
#+end_src
***** test
#+BEGIN_SRC lisp +n -r :results output :exports none :tangle src/tests.lisp
(let* ((list2 (itemize (item "Element 1")
                      (item "Element 2"))))
  (generate-code list2 html t))
#+END_SRC

#+RESULTS:
: <ul>
:   <li>Element 1</li>
:   <li>Element 2</li>
: </ul>

**** link
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(gcode link latex-language ("\\hyperref[~a]{~a}") (target contents))
#+end_src
**** LaTeX escaping utility
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
  (defun escape-latex (string)
    "Escape special LaTeX characters in a string."
    (with-output-to-string (out)
      (loop for char across string
	    do (case char
		 (#\\ (write-string "\\textbackslash{}" out))
		 (#\{ (write-string "\\{" out))
		 (#\} (write-string "\\}" out))
		 (#\$ (write-string "\\$" out))
		 (#\& (write-string "\\&" out))
		 (#\% (write-string "\\%" out))
		 (#\_ (write-string "\\_" out))
		 (#\^ (write-string "\\^{}" out))
		 (#\~ (write-string "\\~{}" out))
		 (#\< (write-string "\\textless{}" out))
		 (#\> (write-string "\\textgreater{}" out))
		 (#\| (write-string "\\textbar{}" out))
		 (otherwise (write-char char out))))))
#+end_src
**** action 
***** code
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(defmethod generate-code ((node action) (lang latex-language) stream)
  ;; Generate the clickable trigger text
  (format stream "\\hyperref[~a]{~a}"
          (target-id node)
          (escape-latex (trigger-text node)))
  (format stream "\\label{~a}" (action-id node))
  
  ;; Generate the action content on a new page
  (format stream "\\newpage~%")
  (format stream "\\section*{~a}~%" (escape-latex (trigger-text node)))
  (format stream "\\label{~a}~%" (target-id node))
  
  ;; Output all contents
  (loop for content in (contents node)
        do (format stream "~a~%" (gcodenil-exp content)))
  
  ;; Add return link at bottom
  (format stream "\\vspace{1em}\\par\\noindent\\hyperref[~a]{\\underline{Go back}}~%"
          (action-id node))
  (format stream "\\newpage~%"))
#+end_src
**** image
***** TODO add alt-text as iamge caption
***** code
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(defmethod generate-code ((node image) (lang latex-language) stream)
  (let* ((align-env (case (align node)
                      (:center "center")
                      (:left "flushleft")
                      (:right "flushright")
                      (t "")))
         (size-option (if (size node)
                        (format nil "[width=~a\\textwidth]" (/ (size node) 100.0))
                        "")))  ; Empty string when no size
    (when align-env
      (format stream "\\begin{~a}~%" align-env))
    
    (format stream "\\includegraphics~a{~a}~%" 
            size-option
            (src node))
    
    (when align-env
      (format stream "\\end{~a}~%" align-env))))
#+end_src
**** sound
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(gcode start-sound latex-language ("~% ~a ~%") (alt-text))
#+end_src
**** video
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(gcode video latex-language ("~% ~a ~%") (alt-text))
#+end_src
**** change-bg-color
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(defmethod generate-code ((node change-bg-color) (lang latex-language) stream)
  (format stream "\\pagecolor{~a}~%" (color node)))
#+end_src
**** change-bg-image
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(defmethod generate-code ((node change-bg-image) (lang latex-language) stream)
  (format stream "\\backgroundsetup{~%")
  (format stream "  scale=1,~%")
  (format stream "  angle=0,~%")
  (format stream "  opacity=1,~%")
  (format stream "  contents={\\includegraphics[width=\\paperwidth,height=\\paperheight]{~a}}~%"
          (image-url node))
  (format stream "}~%"))
#+end_src
**** whiteboard
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(defmethod generate-code ((node whiteboard) (lang latex-language) stream)
  (format stream "~%\\begin{tcolorbox}[~%")
  (format stream "  enhanced,~%")
  (format stream "  colback=white,~%")
  (format stream "  colframe=lightmint,~%")
  (format stream "  arc=4pt,~%")
  (format stream "  boxrule=1pt,~%")
  (format stream "  drop fuzzy shadow,~%")
  (format stream "  title=~a,~%" (wb-title node))
  (format stream "  fonttitle=\\bfseries,~%")
  (format stream "  coltitle=black]~%")
  
  ;; Generate content
  (loop for content in (contents node)
        do (format stream "~a~%" (gcodenil-exp content)))
   
    (format stream "\\vspace{1em}\\par\\noindent\\raggedleft\\textit{~a}~%" 
           (author node))
  
  (format stream "\\end{tcolorbox}~%"))
#+end_src
**** math-inline
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(gcode math-inline latex-language ("$~a$") (math))
#+end_src
**** math-center
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(gcode math-center latex-language ("~%$$~a$$~%") (math))
#+end_src
**** code-node
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
  (defun language-mapping (lang)
    "Maps common language names to lstlistings compatible names"
    (case (intern (string-upcase lang) :keyword)
      (:python "Python")
      (:javascript "JavaScript")
      (:lisp "Lisp")
      (:c++ "C++")
      (:java "Java")
      (:html "HTML")
      (:css "CSS")
      (t (string-capitalize lang))))

  (defmethod generate-code ((node code-node) (lang latex-language) stream)
  (format stream "\\begin{lstlisting}[language=~a]~%~a~%\\end{lstlisting}"
          (language-mapping (language node))
           (format nil "~a"(code node))))
#+end_src

**** scene
***** description
In this section we will generate code for a scene in LaTeX language.
Every scene will be a different page.
***** code
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
(defmethod generate-code ((node scene) (lang latex-language) stream)
  (let ((filename (merge-pathnames 
                   (format nil "~a.tex" (symbol-name (id node)))
                   stream)))
    (ensure-directories-exist filename)
    (with-open-file (f filename
                       :direction :output
                       :if-exists :supersede)
      (format f "\\section{~a} \\label{~a} ~%" (escape-latex (symbol-name (id node))) (escape-latex (symbol-name (id node))) )
      (loop for item in (contents node)
            do (format f "~a~%" (gcodenil-exp item))))))
#+end_src
**** story
***** description
Each story in LaTeX will be a different .tex document
***** code
#+begin_src lisp :results none :export code :tangle src/writer-latex.lisp
  (defmethod generate-code ((node story) (lang latex-language) stream)
    "Generates LaTeX files for all scenes in the story."
    ;; First create the output directory if it doesn't exist
    (ensure-directories-exist stream)

    ;; Generate main.tex file that includes all scene files
    (let ((main-file (merge-pathnames "main.tex" stream)))
      (with-open-file (main main-file
			    :direction :output
			    :if-exists :supersede)
	(format main "\\documentclass{article}~%")
	(format main "\\usepackage{hyperref}~%")
	(format main "\\usepackage{graphicx}~%")
	(format main "\\usepackage{xcolor}~%")
	(format main "\\usepackage{tcolorbox}~%")
	(format main "\\tcbuselibrary{skins}~%")
	(format main "\\definecolor{lightmint}{rgb}{0.63, 0.79, 0.95}~%")
	(format main "\\usepackage{background}~%")
        (format main "\\backgroundsetup{contents={}}~%")
	(format main "\\usepackage[normalem]{ulem}~%")
	(format main "\\usepackage{listings}~%")
	(format main "~%\\lstset{
			basicstyle=\\ttfamily\\small,
			keywordstyle=\\color{blue},
			commentstyle=\\color{green},
			stringstyle=\\color{orange},
			showstringspaces=false,
			breaklines=true,
			frame=single
		    }~%")

	(format main "\\begin{document}~%")
	(format main "\\title{~a}~%" (escape-latex (story-title node)))
	(format main "\\author{~a}~%" (escape-latex (author node)))
	(format main "\\maketitle~%")

	;; Generate table of contents
	(format main "\\tableofcontents~%")
	(format main "\\newpage~%")

	;; Include all scene files
	(loop for element in (contents node)
	      when (typep element 'scene)
		do (format main "\\newpage
	  \\input{~a}~%" (symbol-name (id element))))

	(format main "\\end{document}~%"))

      ;; Generate LaTeX files for each scene
      (loop for element in (contents node)
	    when (typep element 'scene)
	      do (generate-code element latex stream)))

    ;; Return the path to the main file
    (merge-pathnames "main.tex" stream))
#+end_src


* macros to create situations 

** description
The idea behind these macros is that we don't need to add manually the name of the situations to the list.  Let's let a macro do that.

We want something like:

   #+begin_src lisp :results none :export code
   (def-situation name_without_hiphens_nor_uppercases ;; wtf
       (p "Lorem ipsum dolor sit amet, consectetuer adipiscing elit.  Pellentesque condimentum, magna ut suscipit hendrerit, ipsum augue ornare nulla, non luctus diam neque sit amet urna.  Curabitur lacinia pulvinar nibh.  Nulla posuere.  Etiam laoreet quam sed arcu.  "))
   #+end_src
      
And that creates a parameter named =name_without_hiphens_nor_uppercases= and binds it to the instance of the =basic-situation=.

Let's write that code \o/.

** code
   #+begin_src lisp :results none :export code :tangle src/macros.lisp
     (defmacro defbasic-situation (name &body instructions)
       (let* ((situation-id (substitute #\_ #\- 
	     (string-downcase
	     (symbol-name name)))))
	  `(defparameter ,name (basic-situation ,situation-id
			       ,@instructions))))
   #+end_src
   
** testing macroexpansion
   #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (defbasic-situation test-Situation
       (p "Lorem ipsum dolor sit amet, consectetuer adipiscing elit.  ")
       (nline)
       (p "Lorem ipsum dolor sit amet, consectetuer adipiscing elit.  Lorem ipsum dolor sit amet, consectetuer adipiscing elit."))
     (defbasic-situation S-Sit
     (p "STARTING SITUATION")
     (nline)
     (p "Lorem ipsum dolor sit amet, consectetuer adipiscing elit.  Lorem ipsum dolor sit amet, consectetuer adipiscing elit."))
   #+end_src


* macro to create stories

** description
The idea is that we can create stories like this:

#+begin_src lisp :results none :export code
      (defstory historia-de-los-macros
        :initial-situation start3
        :situations (start3
                     ohhhh
                     the-happy-end
                     the-sad-end
                     the-unwritten-end))
   #+end_src
** code
   #+begin_src lisp :results none :export code :tangle src/macros.lisp
   (defmacro defstory (name &key initial-situation situations)
     "Defines a complete story with its situations and initial situation."
       `(defparameter ,name 
	 (story (list ,@situations) 
	 ,(substitute #\_ #\- (string-downcase (symbol-name initial-situation))))))
#+end_src
** tests
   #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (defstory historia-de-los-macros
        :initial-situation S-Sit
        :situations (S-Sit
                    test-Situation))
   #+end_src


* whiteboard commands

** description
We will create a whiteboard in html code. The objective is to use the whiteboard in situations. We will create commands to show and hide the whiteboard, add content, remove content, and clear it.
** render whiteboard
*** description
A function to create the whiteboard html structure.
*** code
#+begin_src lisp :results none :export code :tangle src/utilities.lisp
  (defparameter *whiteboard-content* nil)

  (defun render-whiteboard ()
	   (when *whiteboard-content*
	     (let ((title (getf *whiteboard-content* :title))
		   (content (reverse (getf *whiteboard-content* :content)))
		   (author (getf *whiteboard-content* :author)))
	       (format nil 
		       "<div class='section whiteboard-animate'><div class='whiteboard-wrap'><div class='whiteboard-container'><div class='whiteboard-header'></div><div class='whiteboard-content'><div class='content-title'>~a</div><div class='content-body' id='wb-body'>~{~a~}~:[~;<p class='quote-author'>~a</p>~]</div><div class='bottom'></div></div><div class='whiteboard-footer'></div></div></div></div>"
		       title 
		       content 
		       author author))))

#+end_src
** show whiteboard
*** description
A function to show the whiteboard
*** code
   #+begin_src lisp :results none :export code :tangle src/utilities.lisp
     (defun show-whiteboard (&optional title content author)
       (setf *whiteboard-content* 
	     (list :title (or title "")
		   :content (if content 
				(list (format nil "<p class='fade-in'>~a</p>" content)) 
				nil)
		   :author author))
       (render-whiteboard))
   #+end_src
** hide whiteboard
*** description
A function to hide the whiteboard
*** code
 #+begin_src lisp :results none :export code :tangle src/utilities.lisp
  
   #+end_src
** add content
*** description
A function to add content to the whiteboard using javascript
*** code
#+begin_src lisp :results none :export code :tangle src/utilities.lisp
  (defun add-to-whiteboard (text &key (slow nil) (element-id "wb-body"))
    "Adds content to an existing whiteboard element on the page using JavaScript.
     :text - The content to add
     :slow - Whether to use slow fade-in animation
     :element-id - The ID of the whiteboard content element"
    (let ((animation-class (if slow "slow-fade-in" "fade-in")))
      (format nil 
	      "<script>function add_to_whiteboard() {var whiteboard = document.getElementById('~a'); if (whiteboard) { var newContent = document.createElement('p'); newContent.className = '~a';newContent.innerHTML = '~a'; whiteboard.appendChild(newContent); } } </script>"
	      element-id
	      animation-class
	      text)))
#+end_src

** clear whiteboard
*** description
A function to clear the whiteboard
*** code
#+begin_src lisp :results none :export code :tangle src/utilities.lisp
(defun clear-whiteboard (&optional (element-id "wb-body"))
  "Clears all content from the whiteboard"
  (format nil 
          "<script>function clear_whiteboard() { var whiteboard = document.getElementById('~a'); if (whiteboard) {whiteboard.innerHTML = '';  } } </script>"
          element-id))
#+end_src 

** tests
   

* example to test a story
** description
In this section I'm going to have story written in clif.  This will be the main test for clif :-)

All the code blocks in this section will be tangled to the file test.lisp.
** test2 (using some html elements p and h1, with css-classes)
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* (start
          last
          story1) 
     (bformat t "testing a full story")
     (setf start (basic-situation
                  "start"
                  (h1 "A game with only one situation, but with h1 and p and css")
                  (nline)
                  (p "This is the only situation, with text.")
                  (nline)
                  (p :transient "And this should dissapear...  :-o")
                  (nline)
                  (p :transient "Click" (link "last"" here to end..."))))

     (setf last (basic-situation
                 "last"
                 (p "Congratulations.")
                  (nline)
                 (p "You finished your first adventure.")
                  (nline)
                 (p "THE END")))
     (setf story1 (story (list start last) "start"))
     (format t "~a~%" start)
     (format t "~a~%" last)
     (with-open-file (f "/tmp/undum-game.js"
                        :direction :output
                        :if-exists :supersede)
       (generate-code story1 undum f)))
   #+end_src

   #+RESULTS:
   #+begin_example
   ======================
    testing a full story
   ======================

   basicSituation (start): (<<H1 NIL: (A game with only one situation, but with h1 and p and css)>>
                            <<newline>>
                            <<p NIL: (This is the only situation, with text.)>>
                            <<newline>>
                            <<p (transient): (And this should dissapear...  :-o)>>
                            <<newline>>
                            <<p (transient): (Click
                                              <<link NIL to (last): ( here to end...)>>)>>)
   basicSituation (last): (<<p NIL: (Congratulations.)>> <<newline>>
                           <<p NIL: (You finished your first adventure.)>>
                           <<newline>> <<p NIL: (THE END)>>)
   #+end_example

** test1 (very elemental)
   #+begin_src lisp :results output :export code :tangle src/tests.lisp
   (let* (start
          last)
     (bformat t "testing a full story")
     (setf start (basic-situation
                  'start
                  (list "<h1>Un juego con una sola situaci√≥n</h1>"
                        "<p>Esta es una √∫nica situaci√≥n, con texto.</p>."
                        "<p>Presiona" (link 'ultimo "aqu√≠ para terminar...")"</p>")))

     (setf last (basic-situation
                 'last
                 (list "<p class='transient'>Felicitaciones.</p>."
                       "<p>Has terminado tu primera aventura.</p>"
                       "<p>FIN</p>")))
     (format t "~a~%" start)
     (format t "~a~%" last))
   #+end_
